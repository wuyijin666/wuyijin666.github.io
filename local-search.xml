<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第一天Go (日记纪念版)</title>
    <link href="/2024/04/27/%E7%AC%AC%E4%B8%80%E5%A4%A9Go/"/>
    <url>/2024/04/27/%E7%AC%AC%E4%B8%80%E5%A4%A9Go/</url>
    
    <content type="html"><![CDATA[<p>记录第一天学习go, 附上第一句话：“Hello World!”<br><img src="/images/17.png"></p><p>我被Gopher可爱到了，地鼠啊哈哈哈，怎么会有这么戳我蠢萌点的吉祥物啊，越看越想笑。开GO!</p>]]></content>
    
    
    <categories>
      
      <category>GO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用Go实战IM即时消息系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务架构</title>
    <link href="/2024/04/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/04/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p> 单体架构： 将业务的所有功能集中在一个项目里开发，打成一个包部署。（缺点：耦合度高）适合小型项目，例如：学生管理系统</p><h3 id="分布式架构：-根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。（特点：松耦合，扩展性好）"><a href="#分布式架构：-根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。（特点：松耦合，扩展性好）" class="headerlink" title="分布式架构： 根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。（特点：松耦合，扩展性好）"></a>分布式架构： 根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。（特点：松耦合，扩展性好）</h3><p>分布式架构要考虑的问题：</p><ol><li>服务拆分粒度如何</li><li>服务集群地址如何维护</li><li>服务之间如何实现远程调用</li><li>服务健康状态如何感知</li></ol><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p> 微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征：</p><ol><li>单一职责：微服务拆分粒度更小，每个服务都对应唯一的业务功能，做到单一职责，避免重复业务开发</li><li>面向服务：微服务对外暴露业务接口</li><li>自治：团队独立、技术独立、数据独立、部署独立</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ol>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务技术栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分析布隆过滤器解决缓存穿透问题</title>
    <link href="/2024/04/18/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2024/04/18/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>缓存穿透：由用户大量向缓存和数据库不存在数据发送恶意请求，从而绕过缓存，直接访问数据库，最终导致数据库崩溃。</p><p>如何在海量元素中（例如 10 亿无序、不定长、不重复）快速判断一个元素是否存在。</p><p>这个问题涉及两个关键点：海量数据、快速判断。</p><p>如果我们直接把这些元素的值放到基本的数据结构Set里面，会十分占用空间。</p><p>所以，我们存储这几十亿个元素，不能直接存值，我们应该找到一种最简单的最节省空间的数据结构，用来标记这个元素有没有出现。这个东西我们就把它叫做<mark>位图</mark>，是一个有序的数组，只有两个值，0 和 1。0 代表不存在，1 代表存在。</p><p>要让这个数组标记这些元素是否存在，必须有一个映射方法。</p><p>这个映射方法需要符合一下基本要求：</p><ol><li>因为值长度是不固定的，所以希望不同长度的输入，可以得到固定长度的输出。</li><li>转换成下标的时候，希望在这个有序数组里面分布均匀，不然元素全部挤到一起，无法判断哪个元素存了，哪个没存。</li></ol><p>结合上面两个要求，使用分布性性能优良的哈希函数加上相应的取模方法，可以得到相应下标。<br><img src="/images/10.png"></p><p>具体如上图，数据经过哈希计算并取模得到相应的数组下标，并把该下标值置1，表示存在。<br>然后到时判断数据是否存在时，只需要把数据用相应的函数计算出下标，再查看对应数据元素是否为1，1则存在，0则不存在。</p><p><em><strong>哈希碰撞 :</strong></em> hash碰撞指的是，两个不同的值（比如张三、李四的学号）经过hash计算后，得到的<strong>hash值相同</strong>，后来的李四要放到原来的张三的位置，但是数组的位置已经被张三占了，<strong>导致冲突</strong>。<br>hash碰撞的解决方式是开放寻址法和拉链法<br>hash存数据如下图：<br><img src="/source/images/11.png"></p><p>由于会出现哈希碰撞，此时YaoMing和Kobe Bryant计算出了相同的下标。所以此时使用该方法判断数据是否存在就会出现误差，比如假如Kobe Bryant实际上是不存在，但是YaoMing数据已经把下标6的元素置1了，然后Kobe Bryant经过运算得到下标为6，此时他去查看6元素是否为1，因为YaoMing已经把他置1了，所以会判断Kobe Bryant是存在，但是实际上它是不存在的。</p><p>因为哈希冲突会导致判断出错，所以要尽量减少哈希冲突的概率。方法有：</p><ol><li>增大位图数组的容量，因为我们的函数是分布均匀的，所以，位图容量越大，在同一个位置发生哈希碰撞的概率就越小，但是位图数组容量增大意味着会增大内存的消耗，所以不能不讲道理地扩大位图容量，应该是在错误率和位图容量中平衡取值。</li><li>如果数据经过一次哈希计算，得到的相同下标的概率比较高，如果计算多次呢？ 原本只用一个哈希函数，现在对于每一个要存储的元素都用多个哈希函数计算，这样每次计算出来的下标都相同的概率就小得多了。但是 我们也不讲道理地使用很多次的哈希计算函数，因为很多次的哈希计算会消耗掉cpu的性能，和延长判断速度。<br>所以总的来说，我们既要节省空间，又要很高的计算效率，就必须<mark>在位图容量和函数个数之间找到一个最佳的平衡</mark>。</li></ol><p>对于如何取得平衡，这个事情早就有人研究过了，在 1970 年的时候，有一个叫做布隆的前辈对于判断海量元素中元素是否存在的问题进行了研究，也就是到底需要多大的位图容量和多少个哈希函数，它发表了一篇论文，提出的这个容器就叫做布隆过滤器。</p><p>但是无论如果也不可能达到100%正确率，除非使用绝对均匀的下标算法和绝对大于元素个数且随时扩容的位数组。</p><p>所以，这个是布隆过滤器的一个很重要的特性，因为哈希碰撞不可避免，所以它会存在一定的误判率。这种把本来不存在布隆过滤器中的元素误判为存在的情况，我们把它叫做假阳性（False Positive Probability，FPP）。</p><h2 id="布隆过滤器的特点："><a href="#布隆过滤器的特点：" class="headerlink" title="布隆过滤器的特点："></a>布隆过滤器的特点：</h2><p> <strong>容器角度</strong>：</p><ol><li><p>如果布隆过滤器判断结果为元素存在，那么该元素实际上元素不一定会存在，由于哈希碰撞，所以会存在一定误判率，上面已经说明了。</p></li><li><p>如果布隆过滤器判断结果为元素不存在，那么他就一定不存在，因为无论哈希碰撞啥的，只要该元素计算出下标值对应数组元素值为0，那么该元素就必定不存在.</p></li></ol><p>布隆过滤器是不支持删除元素的，因为如果位图的某个位置被多个元素占用着，那么如果删除其中一个元素是否能将该位置0,能置0的话会影响到其他元素，不置0就等于没删除。</p><p> <strong>元素角度</strong>：</p><ol><li><p>如果元素实际存在，布隆过滤器可能判断存在，也可能判断为不存在，存在误判。<br>如果元素实际不存在，布隆过滤器一定判断不存在。</p></li><li><p>利用第二个特性，我们就能解决持续从数据库查询不存在的值的问题，把要查询的值先过布隆过滤器，判断是否存在，存在就走redis缓存，不存在就直接返回，并且配合缓存空值，可以有效解决缓存穿透问题，虽然存在一定误差，但是在业务范围内允许接受。<br><img src="/images/12.png"></p></li></ol><h2 id="布隆过滤器实战"><a href="#布隆过滤器实战" class="headerlink" title="布隆过滤器实战"></a>布隆过滤器实战</h2><p>我们可以引入最新的坐标，然后就可以使用了<br>所用： Guava：Java开发者的全方位工具库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;<br>    &lt;artifactId&gt;guava&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">31.1</span>-jre&lt;/version&gt;<br>&lt;/dependency&gt;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.bloomfilterdemo;<br><br><span class="hljs-keyword">import</span> com.google.common.base.Charsets;<br><span class="hljs-keyword">import</span> com.google.common.hash.BloomFilter;<br><span class="hljs-keyword">import</span> com.google.common.hash.Funnels;<br><br><span class="hljs-keyword">import</span> java.text.NumberFormat;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@decription</span></span><br><span class="hljs-comment"> * 测试布隆过滤器的正确判断和误判</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 往布隆过滤器里面存放100万个元素</span><br><span class="hljs-comment"> * 测试100个存在的元素和9900个不存在的元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomFilterDemo</span> &#123;<br>    <span class="hljs-comment">//元素个数100万个</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">insertions</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建一个布隆过滤器，第二个值是元素的个数</span><br>        <span class="hljs-comment">//初始化一个存储String数据的布隆过滤器，初始化大小为100w</span><br>        <span class="hljs-comment">//默认误判率是0.03</span><br>        BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), insertions, <span class="hljs-number">0.03D</span>);<br><br>        <span class="hljs-comment">//用于存放所有实际存在的key,判断key是否存在，可快速判断key存在&lt;</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(insertions);<br><br>        <span class="hljs-comment">//用于存放所有实际存在的key,可以取出使用，这个可供使用下标取出</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(insertions);<br><br>        <span class="hljs-comment">//插入数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; insertions; i++) &#123;<br>            <span class="hljs-comment">//UUID 是 通用唯一识别码(Universally Unique Identifier)，主要是让分布式系统中的所有元素，都有唯一的辨识信息</span><br>            <span class="hljs-comment">//随机生成UUID的标识符是UUID类中的方法</span><br>            <span class="hljs-comment">//而UUID.randomUUID().toString()是javaJDK提供的一个自动生成主键的方法</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>            bloomFilter.put(uuid);<br>            set.add(uuid);<br>            list.add(uuid);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">wrong</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-comment">//可以被100整除的时候，取一个存在的数。否则随机生成一个UUID</span><br>            <span class="hljs-comment">//0-10000之间，可以被100整除的数有100个（100的倍数)</span><br>            <span class="hljs-comment">//这里就是实现100个存在key,9900个不存在key</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> i % <span class="hljs-number">100</span> == <span class="hljs-number">0</span> ? list.get(i / <span class="hljs-number">100</span>) : UUID.randomUUID().toString();<br><br>            <span class="hljs-comment">// bloomFilter.mightContain(data)   布隆过滤器提供的方法用于判断数据是否命中</span><br>            <span class="hljs-keyword">if</span> (bloomFilter.mightContain(data)) &#123;<br>                <span class="hljs-keyword">if</span> (set.contains(data)) &#123;<br>                    <span class="hljs-comment">//判断存在，实际存在的时候，命中</span><br>                    right++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//判断存在却不存在的时候，错误++</span><br>                wrong++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//计算命中率和误判率</span><br>        <span class="hljs-type">NumberFormat</span> <span class="hljs-variable">percentFormat</span> <span class="hljs-operator">=</span> NumberFormat.getPercentInstance();<br>        percentFormat.setMaximumFractionDigits(<span class="hljs-number">2</span>); <span class="hljs-comment">//最大小数位数</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">percent</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) wrong / <span class="hljs-number">9900</span>;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">bingo</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (<span class="hljs-number">9900</span> - wrong) / <span class="hljs-number">9900</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;在100W个元素中，判断100个实际存在的元素，布隆过滤器认为存在的： &quot;</span> + right);<br>        System.out.println(<span class="hljs-string">&quot;在100W个元素中，判断9900个实际不存在的元素，布隆过滤器误认为存在的：&quot;</span> + wrong + <span class="hljs-string">&quot;&quot;</span> +<br>                <span class="hljs-string">&quot;,命中率: &quot;</span> + percentFormat.format(bingo) + <span class="hljs-string">&quot;,误判率：&quot;</span> + percentFormat.format(percent));<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">numOfBits</span> <span class="hljs-operator">=</span> optimalNumOfBits(insertions, <span class="hljs-number">0.03D</span>);<br>        System.out.println(<span class="hljs-string">&quot;100w个元素，误判率为3%的情况下，位图容量为：&quot;</span> + (numOfBits / <span class="hljs-number">8.0</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;100w个元素，误判率为3%的情况下，哈希函数个数为：&quot;</span> + (optimalNumOfHashFunctions(insertions, numOfBits)) + <span class="hljs-string">&quot;个&quot;</span>);<br><br>    &#125;<br><br>    <br>        <span class="hljs-comment">//下面两个方法是BloomFilter的方法，只是在里面是包权限，这里就直接复制出来用了。</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 计算出哈希函数个数</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> expectedInsertions  期望元素个数</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> numOfBits  位图容量</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">optimalNumOfHashFunctions</span> <span class="hljs-params">( <span class="hljs-type">long</span> expectedInsertions, <span class="hljs-type">long</span> numOfBits)</span>&#123;<br>            <span class="hljs-keyword">return</span> Math.max(<span class="hljs-number">1</span>, (<span class="hljs-type">int</span>) Math.round((<span class="hljs-type">double</span>) numOfBits / (<span class="hljs-type">double</span>) expectedInsertions * Math.log(<span class="hljs-number">2.0D</span>)));<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 计算出位图容量</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> expectedInsertions 期望元素个数</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> fpp  误判率</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">optimalNumOfBits</span> <span class="hljs-params">( <span class="hljs-type">long</span> expectedInsertions, <span class="hljs-type">double</span> fpp)</span>&#123;<br>            <span class="hljs-keyword">if</span> (fpp == <span class="hljs-number">0.0D</span>) &#123;<br>                fpp = <span class="hljs-number">4.9E-324D</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>) ((<span class="hljs-type">double</span>) (-expectedInsertions) * Math.log(fpp) / (Math.log(<span class="hljs-number">2.0D</span>) * Math.log(<span class="hljs-number">2.0D</span>)));<br>        &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/13.png"><br>连续多次的执行结果，误判率都在3%左右，因为默认的误判率为3%。并且使用0.87MB的位图容量加5个哈希函数就可以达到100w数据的快速判断是否存在。只是存在3%的误判率。<br>可以指定误判率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//最后一个参数就是误判率，这里设置的是0.1  10%。</span><br>BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8),insertions,<span class="hljs-number">0.1D</span>);<br></code></pre></td></tr></table></figure><p>布隆过滤器会根据元素个数和误判率来自动跳转哈希函数个数和位数组的容量。</p><h2 id="布隆过滤器其他应用场景："><a href="#布隆过滤器其他应用场景：" class="headerlink" title="布隆过滤器其他应用场景："></a>布隆过滤器其他应用场景：</h2><ol><li>海量数据过滤</li><li>数据url爬虫，爬海量url</li><li>还有我们的邮箱服务器，发送垃圾邮件的账号我们把它们叫做 spamer，在这么多的邮箱账号里面，怎么判断一个账号是不是 spamer 等一些场景</li></ol><p>布隆过滤器的优点是海量数据、快速判断，缺点是存在一定的误判率。</p><p>存储10亿个UUID，使用的内存对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Obj1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">insertions</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000000</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString().getBytes().length*insertions;<br>        System.out.println(<span class="hljs-string">&quot;用set存储10亿个UUID，消耗内存：&quot;</span>+(g/<span class="hljs-number">1024.0</span>/<span class="hljs-number">1024.0</span>/<span class="hljs-number">1024.0</span>) + <span class="hljs-string">&quot;GB&quot;</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">numOfBits</span> <span class="hljs-operator">=</span> BloomFilterDemo.optimalNumOfBits(insertions,<span class="hljs-number">0.03D</span>);<br>        System.out.println(<span class="hljs-string">&quot;10亿个元素，误判率为3%的情况下，位图容量为：&quot;</span>+(numOfBits/<span class="hljs-number">8.0</span>/<span class="hljs-number">1024</span>/<span class="hljs-number">1024</span>/<span class="hljs-number">1024</span>)+<span class="hljs-string">&quot;GB&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;10亿个元素，误判率为3%的情况下，哈希函数个数为：&quot;</span>+(BloomFilterDemo.optimalNumOfHashFunctions(insertions,numOfBits))+<span class="hljs-string">&quot;个&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/14.png"><br>用set存储，需要33.527GB内存，<strong>用布隆过滤器只需0.849GB+5个哈希函数计算+3%的误判率，差了39.5倍</strong>，但是要牺牲一定准确性。并且布隆过滤器的位图增长只会与元素个数有关，与元素的大小没有关系，而用set存储的话，还与元素的大小有关，假如每个元素达到1kb大小，那结果不堪设想…</p>]]></content>
    
    
    <categories>
      
      <category>缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>海量数据、快速判断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Redis为何那么快（二）</title>
    <link href="/2024/04/15/%E6%B5%85%E8%B0%88Redis%E4%B8%BA%E4%BD%95%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/04/15/%E6%B5%85%E8%B0%88Redis%E4%B8%BA%E4%BD%95%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="高效的内存数据结构"><a href="#高效的内存数据结构" class="headerlink" title="高效的内存数据结构"></a>高效的内存数据结构</h1><p><img src="/images/7.png"></p><h3 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h3><p>动态字符串是一种能够动态扩展长度的字符串实现方式。SDS是Redis中的一种简单动态字符串结构，它是一种动态大小的字节数组，用于存储和操作字符串数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * redis中保存字符串对象的结构</span><br><span class="hljs-comment"> */</span><br>struct sdshdr &#123;<br>    <span class="hljs-comment">//用于记录buf数组中使用的字节的数目，和SDS存储的字符串的长度相等 </span><br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-comment">//用于记录buf数组中没有使用的字节的数目 </span><br>    <span class="hljs-type">int</span> free;<br>    <span class="hljs-comment">//字节数组，用于储存字符串</span><br>    <span class="hljs-type">char</span> buf[]; <span class="hljs-comment">//buf的大小等于len+free+1，其中多余的1个字节是用来存储’\0’的</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>Redis的SDS的数据结构使用一个len字段记录当前字符串的长度，使用free表示空闲的长度。想要获取长度只需要获取len字段即可。<br><img src="/images/8.png"><br>而对比C语言，传统字符串是使用长度为N+1的字符数组来表示长度为 的字符串，并且字符串数组的最后一个元素总是空字符’\0’。<br>SDS相对于C语言字符串有如下优点：</p><ol><li><strong>二进制安全</strong> :SDS可以存储任意二进制数据，而不仅仅是文本字符串(包括图片、视频、音频等在内的各种二进制数据)，而不会受到空字符或者特殊字符的限制，具有更广泛的适用性。</li><li><strong>动态扩展</strong> : SDS可以根据存储的字符串长度动态调整，根据实际需要动态分配和释放内存空间。</li><li><strong>O(1)时间复杂度</strong> </li><li><strong>缓冲区溢出保护</strong> : SDS在存储字符串时，会自动添加一个空字符串（’\O’）作为字符串的结束标志，保证字符串的安全性和稳定性。</li><li><strong>惰性空间释放</strong> : 当SDS缩短字符串时，并不会立即释放多余空间，多余空间会保存下来，以备后续再利用。这种惰性空间释放策略可以减少内存分配和释放的开销，提高内存利用率。</li></ol><h3 id="双端链表"><a href="#双端链表" class="headerlink" title="双端链表"></a>双端链表</h3><p>Redis中的双端链表是一种经过优化的数据结构，用于存储有序数据集合。它具有双向连接的特性，每个节点都包含前一个节点和后一个节点的指针。<br><img src="/images/9.png"><br>在Redis中，双端链表节点的定义通常如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span>  <span class="hljs-comment">// 指向前一个节点的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 指向后一个节点的指针</span><br>    <span class="hljs-type">void</span> *value;            <span class="hljs-comment">// 存储的数据元素</span><br>&#125; listNode;<br></code></pre></td></tr></table></figure><p>对于链表中描述链表整体属性的元数据，它的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br>    listNode *head;  <span class="hljs-comment">// 头节点指针</span><br>    listNode *tail;  <span class="hljs-comment">// 尾节点指针</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;  <span class="hljs-comment">// 链表长度</span><br>    <span class="hljs-comment">// 其他字段...</span><br>&#125; <span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure><ol><li><strong>头结点</strong>（head node): 头结点是双端链表中的第一个节点，也是链表的入口。通常用于存储链表的起始位置信息，以便快速定位链表的起始位置。在双端链表中，头结点的特点是没有前一个节点，即头结点的 prev 为 NULL。头结点通常用于存储链表的头部元数据或者哨兵节点。</li><li><strong>尾结点</strong> (tail node): 尾结点是双端链表中的第一个节点，也是链表的结束位置。通常用于存储链表的结束位置信息，以便快速定位链表的结束位置。在双端链表中，尾结点的特点是没有最后一个节点，即尾结点的 next 为 NULL。尾结点通常用于存储链表的尾部元数据或者哨兵节点。</li></ol><p>通过头节点和尾节点，可以方便地对双端链表进行头部插入、尾部插入、头部删除、尾部删除等操作，从而实现了对双端链表的高效操作。<br>除了上述头尾节点以外，链表的元数据中还有len参数，这个参数用于记录链表的当前长度。每当链表中添加或删除节点时，Redis会相应地更新len字段的值，以反映链表的当前长度。这个参数与SDS里类似，获取链表长度时不用再遍历整个链表，直接拿到len值就可以了，这个时间复杂度是 O(1)。</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>本文探讨Redis之所以快速处理大规模数据的原因</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《论持久战》顶级战略思维</title>
    <link href="/2024/04/15/%E8%8A%B1%E4%B8%80%E5%B9%B4%E8%AF%BB%E6%AF%9B%E9%80%89/"/>
    <url>/2024/04/15/%E8%8A%B1%E4%B8%80%E5%B9%B4%E8%AF%BB%E6%AF%9B%E9%80%89/</url>
    
    <content type="html"><![CDATA[<h3 id="写作背景"><a href="#写作背景" class="headerlink" title="写作背景"></a>写作背景</h3><p>《论持久战》写于1938年，日军全面侵华刚开始，当时亡国论和速胜论等多方声音盘旋，这篇文章主要是给战争态势做一个分析与总结，并且牵引革命前行的一个演讲。</p><h3 id="二维辩证法分析矩阵"><a href="#二维辩证法分析矩阵" class="headerlink" title="二维辩证法分析矩阵"></a>二维辩证法分析矩阵</h3><pre><code class="hljs">中国内部 中国外部日本内部 日本外部</code></pre><p><img src="/images/6.png"><br>在这篇文章中，教员分析到 战争的胜利取决于三个方面：</p><ol><li>中国抗日统一战线的完成</li><li>国际抗日统一战线的完成</li><li>日本国内人民和日本殖民地人民的革命运动的兴起<br>就中国人民的立场来说，三个条件中，中国人民的大联合是主要的。</li></ol><h4 id="外因的存在加速了内部矛盾的转化"><a href="#外因的存在加速了内部矛盾的转化" class="headerlink" title="外因的存在加速了内部矛盾的转化"></a>外因的存在加速了内部矛盾的转化</h4><p>摘：<em><strong>历史积累下来的腐败现象，虽然很严重地阻碍着人民抗战力量增长的速度，减少了战争的胜利，招致了战争的损失，但是中国、日本和世界的大局，不容许中国人民不进步。由于阻碍进步的因素即腐败现象之存在，这种进步是缓慢的。进步和进步缓慢是目前时局的两个特点，后一个特点和战争的迫切要求很不相称。然而我们是在革命战争中，革命战争是一种抗毒素，它不但将排除敌人的毒焰、也将清除自己的污浊。</strong></em></p><p>教员分析了中国当时的外部环境和日本当时的外部环境。<br>同时也涉及了论持久战中的道义问题。</p><p>摘：<em><strong>日本虽能得到国际法西斯国家的援助，但同时，却又不能不遇到一个超过其国际援助力量的国际反对力量。这后一种力量将逐渐地增长，终究不但将前者的援助力量抵消，并将施其压力于日本自身。</strong></em></p><h4 id="目标定力：如何看懂-妥协？迂回"><a href="#目标定力：如何看懂-妥协？迂回" class="headerlink" title="目标定力：如何看懂 妥协？迂回"></a>目标定力：<em><strong>如何看懂 妥协？迂回</strong></em></h4><p>很简单，妥协是目标层面的事情，迂回是执行层面的事情。<br>我党战争经常讲究迂回策略，十六字箴言：<strong>敌进我退，敌驻我扰，敌疲我打，敌退我追。</strong></p><h4 id="长期主义"><a href="#长期主义" class="headerlink" title="长期主义"></a>长期主义</h4><p>从1931年九一八事变开始到1945年8月15日，14年，全国人民都在做一件事：把日本鬼子赶出中国。<br>1938年初，教员在长期主义战略思维下，认为抗日战争分为三阶段：</p><ol><li>第一阶段：敌之战略进攻，我之战略防御</li><li>第二阶段（<strong>战略相持阶段</strong>）：敌之战略保守，我之准备反攻</li><li>第三阶段：我之战略进攻，敌之战略退却</li></ol><p>战略相持阶段，是最考验、最痛苦的阶段。教员分析：<em><strong>大体上我们要准备付给较长的时间，要熬得过这段艰难的路程。这将是中国很痛苦的时期，经济困难和汉奸捣乱将是两个很大的问题。敌人将大肆其破坏中国统一战线的活动，一切敌之占领地的汉奸组织将合流组成所谓“统一政府”。我们内部，因大城市的丧失和战争困难，动摇分子将大倡其妥协轮，悲观情绪将严重增长。此时我们的任务，在于动员全国民众，齐心一致，绝不动摇地坚持战争，把统一战线扩大和巩固起来，排除一切悲观主义和妥协论，提倡艰苦斗争，实行新的战时政策，熬过这一艰难路程。</strong></em></p><p>排除一切悲观主义，熬过去，拨云见日，看到更大的风景。</p><p>摘：这个第二阶段是整个战争的过渡阶段，也将是最困难的时期，然而它是转变的枢纽。<em><strong>中国将变为独立国，还是沦为殖民地，不决定第一阶段大城市之是否丧失，而决定于第二阶段全民族努力的程度。</strong></em> 如能坚持抗战，坚持统一战线和坚持持久战，中国将在此阶段中获得转弱为强的力量。中国抗战的三幕戏，这是第二幕。由于全体演员的努力，最精彩地结幕便能很好地演出来。</p><h4 id="动态视角"><a href="#动态视角" class="headerlink" title="动态视角"></a>动态视角</h4><p>一般人看援助力量是多是少，而教员是看 <strong>援助力量的变化速度</strong></p><ol><li>中国抗日战争的正义性和进步性</li><li>中国之大国，有打持久战的能力</li></ol><p>摘：这就是战争中的经验，军队的进步，政治的进步，人民的动员，文化的新方向的发展，游击战的出现，国际援助的增长等等。在第一阶段，向下的东西是旧的量和质，主要地表现在量上。向上的东西是新的量和质，主要地表现在质上。这第二种变化，就给了我们以能够持久和最后胜利的根据。</p><p>要减少 唯心主义 和 机械论</p><p>摘：<em><strong>所谓“唯武器论”，是战争问题中的机械论，是主观和片面看问题的意见。要看武器，更要看人力。武器是战争的重要因素，但不是决定因素，决定因素是人不是物。力量对比不单是军力与经济力的对比，而且是人力与人心的对比。军力和经济力是要人去掌握的。中国只要坚持抗战和统一战线，其军力和经济力是能够逐渐地加强的。</strong></em></p><p>摘：谁人不知，为争取时间和准备反攻而流血战斗，某些土地虽仍不能免于放弃，时间却争取了，给敌以歼灭和给敌以消耗的目的却达到了，自己的战斗经验却取得了，没有起来的人民却起来了，国际地位却增长了。这种血是白流的吗？一点也不是白流的。放弃土地是为了保存军力，也正是为了保存土地。</p><p>摘：<strong>资本家做生意是要有本钱的，全部破产之后，也算不得什么资本家。赌汉也要赌本，孤注一掷，不幸不中，就无从再赌。事务是往返曲折的，不是径情直遂的，战争也是一样，只有形式主义者想不通这个道理。</strong></p>]]></content>
    
    
    <categories>
      
      <category>毛选</category>
      
    </categories>
    
    
    <tags>
      
      <tag>详细读《论持久战》，关于辩证的矛盾分析、战略定力和长期主义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal（3）常见使用场景</title>
    <link href="/2024/04/14/ThreadLocal(3)/"/>
    <url>/2024/04/14/ThreadLocal(3)/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal-常见使用场景"><a href="#ThreadLocal-常见使用场景" class="headerlink" title="ThreadLocal 常见使用场景"></a>ThreadLocal 常见使用场景</h3><p>ThreadLocal作用在每一个线程内都需要独立的保存信息，这样就方便同一个线程的其他方法获取到该信息的场景，由于每一个线程获取到的信息可能都不一样，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal直接获取到，避免了传参，类似于全局变量的概念。比如像用户登录令牌解密后的信息传递、用户权限信息、从用户系统中获取到的用户名。<br><img src="/images/15.png"><br>如上图，线程创建了变量A,方法二是跟方法一在同一个线程内，变量A在该线程中共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用户微服务配置token解密信息传递例子</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">ThreadLocal</span><span class="hljs-params">(LoginUser)</span> threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>     <span class="hljs-type">LoginUser</span> <span class="hljs-variable">loginUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginUser</span>();<br>     loginUser.setId(id);<br>     loginUser.setName(name);<br>     loginUser.setMail(mail);<br>     loginUser.setHeadImg(headImg);<br>     threadLocal.set(loginUser);<br><br>后续想直接获取到，就threadLocal.getXXX即可<br></code></pre></td></tr></table></figure><h3 id="如何用ThreadLocal实现线程安全的问题"><a href="#如何用ThreadLocal实现线程安全的问题" class="headerlink" title="如何用ThreadLocal实现线程安全的问题"></a>如何用ThreadLocal实现线程安全的问题</h3><p>ThreadLocal适用于如下两种场景：</p><ol><li>每个线程需要自己单独的实例</li><li>实例需要在多个方法中共享，但不希望被多线程共享</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>存储用户Session</li></ol>]]></content>
    
    
    <categories>
      
      <category>多线程与并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈Threadlocal（3）常见使用场景</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Threadlocal（2）（源码分析）</title>
    <link href="/2024/04/14/ThreadLocal(2)/"/>
    <url>/2024/04/14/ThreadLocal(2)/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal原理（源码分析）"><a href="#ThreadLocal原理（源码分析）" class="headerlink" title="ThreadLocal原理（源码分析）"></a>ThreadLocal原理（源码分析）</h3><ol><li>ThreadLocal的set方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span>&#123;<br>    <span class="hljs-comment">//1.获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//2. 获取线程中的属性threadLocalMap,若threadLocalMap不为空，则直接更新要保存的变量值；</span><br>    <span class="hljs-comment">//否则创建threadLocalMap，并赋值。</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span>(map != <span class="hljs-literal">null</span>)&#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-comment">//初始化threadLocalMap 并赋值</span><br>      creatMap(t, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>从上面代码可知，ThreadLocal set赋值时首先会获取当前线程thread,并获取thread线程中的threadLocalMap属性。如果map属性不为空，则直接更新value值，如果为空，则实例化threadLocalMap，并赋值。</li></ol><p>接下来分析一下 threadLocalMap 和 createMap 的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br> <br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * The entries in this hash map extend WeakReference, using</span><br><span class="hljs-comment">       * its main ref field as the key (which is always a</span><br><span class="hljs-comment">       * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="hljs-comment">       * == null) mean that the key is no longer referenced, so the</span><br><span class="hljs-comment">       * entry can be expunged from table.  Such entries are referred to</span><br><span class="hljs-comment">       * as &quot;stale entries&quot; in the code that follows.</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>          <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>          Object value;<br> <br>          Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>              <span class="hljs-built_in">super</span>(k);<br>              value = v;<br>          &#125;<br>      &#125;<br> <br>      <br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看出 ThreadLocalMap是 ThreadLocal的静态类，它的构成主要用Entry来保存数据，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个是threadlocal 的内部方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>        t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>    &#125;<br> <br> <br>    <span class="hljs-comment">//ThreadLocalMap 构造方法</span><br>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>            table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>            table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>            size = <span class="hljs-number">1</span>;<br>            setThreshold(INITIAL_CAPACITY);<br>        &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>ThreadLocal的get方法： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-comment">//1. 获取当前线程</span><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>   <span class="hljs-comment">//2. 获取当前线程的ThreadLocalMap</span><br>   <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>   <span class="hljs-comment">//3. 如果map不为空</span><br>   <span class="hljs-keyword">if</span>(map != <span class="hljs-literal">null</span>)&#123;<br>       <span class="hljs-comment">//获取ThreadLocalMap中存储的值</span><br>       ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>       <span class="hljs-keyword">if</span>(e != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>           <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>           <span class="hljs-keyword">return</span> result;<br>       &#125;<br>   &#125; <br>   <span class="hljs-comment">//如果数据为null,则初始化，初始化结果，ThreadLocalMap中存放key值为ThreadLocal,值为null</span><br>   <span class="hljs-keyword">return</span> setInitialValue();<br><br>   <span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>       <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>       <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>           map.set(<span class="hljs-built_in">this</span>, value);<br>       <span class="hljs-keyword">else</span><br>           createMap(t, value);<br>       <span class="hljs-keyword">return</span> value;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>ThreadLocal的remove方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span>(m != <span class="hljs-literal">null</span>)&#123;<br>        m.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><strong>remove方法，直接将ThreadLocal对应的值从当前线程Thread中ThreadLocalMap中删除。为何删除，这涉及内存泄漏 （memory leak，指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。）的问题。</strong><br> 实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</li></ol><p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p><p>ThreadLocal其实是与线程绑定的一个变量，如此就会出现一个问题：如果没有将ThreadLocal内的变量删除（remove）或替换，它的生命周期将会与线程共存。通常线程池中对线程管理都是采用线程复用的方法，在线程池中线程很难结束甚至于永远不会结束，这将意味着线程持续的时间将不可预测，甚至与JVM的生命周期一致。举个例字，如果ThreadLocal中直接或间接包装了集合类或复杂对象，每次在同一个ThreadLocal中取出对象后，再对内容做操作，那么内部的集合类和复杂对象所占用的空间可能会开始持续膨胀。</p><h4 id="ThreadLocal与Thread，ThreadLocalMap之间的关系"><a href="#ThreadLocal与Thread，ThreadLocalMap之间的关系" class="headerlink" title="ThreadLocal与Thread，ThreadLocalMap之间的关系"></a>ThreadLocal与Thread，ThreadLocalMap之间的关系</h4><p><img src="/images/3.png"><br><img src="/images/4.png"><br>从这个图中我们可以非常直观的看出，ThreadLocalMap其实是Thread线程的一个属性值，而ThreadLocal是维护ThreadLocalMap这个属性值的一个工具类。<mark>Thread线程可以拥有多个ThreadLocal维护的自己线程独享的共享变量</mark>（这个共享变量只是针对自己线程里面共享）</p>]]></content>
    
    
    <categories>
      
      <category>多线程与并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈Threadlocal（2）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Threadlocal（1）</title>
    <link href="/2024/04/13/ThreadLocal/"/>
    <url>/2024/04/13/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h3><h4 id="ThreadLocal-线程变量-，意思是ThreadLocal中填充的变量属于当前线程。该变量对其他线而言是隔离的，该变量是当前线程的独有变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。"><a href="#ThreadLocal-线程变量-，意思是ThreadLocal中填充的变量属于当前线程。该变量对其他线而言是隔离的，该变量是当前线程的独有变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。" class="headerlink" title="ThreadLocal  (线程变量)，意思是ThreadLocal中填充的变量属于当前线程。该变量对其他线而言是隔离的，该变量是当前线程的独有变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。"></a>ThreadLocal <mark> (线程变量)</mark>，意思是ThreadLocal中填充的变量属于当前线程。该变量对其他线而言是隔离的，该变量是当前线程的独有变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</h4><p><em><strong>它的使用场合主要是为了解决多线程中因为数据并发产生不一致问题。</strong></em></p><p>ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：</p><ol><li>因为每个 Thread 内有自己的实例副本，且<mark>该副本只能由当前 Thread 使用</mark>。这是也是 ThreadLocal 命名的由来。</li><li>既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就<mark>不存在多线程间共享的问题</mark>。</li><li>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</li></ol><h4 id="总的来说，ThreadLocal-适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景"><a href="#总的来说，ThreadLocal-适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景" class="headerlink" title="总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景."></a>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景.</h4><p>下图是ThreadLocal在使用过程中的状态：<br><img src="/images/1.png"></p><h3 id="ThreadLocal与Synchronized的区别"><a href="#ThreadLocal与Synchronized的区别" class="headerlink" title="ThreadLocal与Synchronized的区别"></a>ThreadLocal与Synchronized的区别</h3><p>ThreadLocal<T>其实是与线程绑定的一个变量。ThreadLocal和Synchonized都用于解决多线程并发访问。</p><p>ThreadLocal与Synchronized本质区别在于： </p><ol><li>Synchronized用于线程间的数据共享，而ThreadLocal用于线程间的数据隔离。</li><li>Synchronized利用锁机制，使变量或代码块在某一时刻只能被一个线程访问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的共享。而Synchronized却正好相反，用于在多个线程间通信是数据共享。</li></ol><p><em><strong>一句话理解ThreadLocal，threadlocl是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry（threadlocl,value），虽然不同的线程之间threadlocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二的，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程中这个value变量地址是一样的。</strong></em></p><h3 id="ThreadLocal的简单使用"><a href="#ThreadLocal的简单使用" class="headerlink" title="ThreadLocal的简单使用"></a>ThreadLocal的简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocaDemo</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;String&gt;();<br> <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">//打印当前线程中本地内存中本地变量的值</span><br>        System.out.println(str + <span class="hljs-string">&quot; :&quot;</span> + localVar.get());<br>        <span class="hljs-comment">//清除本地内存中的本地变量</span><br>        localVar.remove();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br> <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                ThreadLocaDemo.localVar.set(<span class="hljs-string">&quot;local_A&quot;</span>);<br>                print(<span class="hljs-string">&quot;A&quot;</span>);<br>                <span class="hljs-comment">//打印本地变量</span><br>                System.out.println(<span class="hljs-string">&quot;after remove : &quot;</span> + localVar.get());<br>               <br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br> <br>        Thread.sleep(<span class="hljs-number">1000</span>);<br> <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                ThreadLocaDemo.localVar.set(<span class="hljs-string">&quot;local_B&quot;</span>);<br>                print(<span class="hljs-string">&quot;B&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;after remove : &quot;</span> + localVar.get());<br>              <br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br>&#125;<br> <br>A :local_A<br>after remove : <span class="hljs-literal">null</span><br>B :local_B<br>after remove : <span class="hljs-literal">null</span><br> <br></code></pre></td></tr></table></figure><p>从该示例中，两个线程分别获取自己线程存放的变量，变量获取不会错乱。</p>]]></content>
    
    
    <categories>
      
      <category>多线程与并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈Threadlocal（1）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/13/hello-world/"/>
    <url>/2024/04/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Redis为何那么快（一）</title>
    <link href="/2024/03/29/%E6%B5%85%E8%B0%88Redis%E4%B8%BA%E4%BD%95%E9%82%A3%E4%B9%88%E5%BF%AB/"/>
    <url>/2024/03/29/%E6%B5%85%E8%B0%88Redis%E4%B8%BA%E4%BD%95%E9%82%A3%E4%B9%88%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="我们从Redis基于内存操作的特性、高效的内存数据结构、单线程模型、I-O多路复用技术、底层模型和优化技术、持久化机制以及网络通信协议等多个方面进行分析和讨论。通过深入了解Redis内部机制和性能优化技术，我们可以更好地理解Redis之所以快速地根本原因＋在实际应用中发挥其优势。"><a href="#我们从Redis基于内存操作的特性、高效的内存数据结构、单线程模型、I-O多路复用技术、底层模型和优化技术、持久化机制以及网络通信协议等多个方面进行分析和讨论。通过深入了解Redis内部机制和性能优化技术，我们可以更好地理解Redis之所以快速地根本原因＋在实际应用中发挥其优势。" class="headerlink" title="我们从Redis基于内存操作的特性、高效的内存数据结构、单线程模型、I&#x2F;O多路复用技术、底层模型和优化技术、持久化机制以及网络通信协议等多个方面进行分析和讨论。通过深入了解Redis内部机制和性能优化技术，我们可以更好地理解Redis之所以快速地根本原因＋在实际应用中发挥其优势。"></a>我们从Redis基于内存操作的特性、高效的内存数据结构、单线程模型、I&#x2F;O多路复用技术、底层模型和优化技术、持久化机制以及网络通信协议等多个方面进行分析和讨论。通过深入了解Redis内部机制和性能优化技术，我们可以更好地理解Redis之所以快速地根本原因＋在实际应用中发挥其优势。</h4><p><img src="/images/2.png"></p><h1 id="完全基于内存"><a href="#完全基于内存" class="headerlink" title="完全基于内存"></a>完全基于内存</h1><h6 id="相较于依赖磁盘存储的传统数据库系统，Redis巧妙地运用内存的高速读写特性，显著提高系统的响应速度与整体性能表现。内存相对于磁盘具有无可比拟的读写速度优势。在读取操作层面，Redis无需经过耗时的磁盘IO过程，只需在内存空间内迅速定位所需数据，显著降低访问延迟；而在写入操作时，Redis同样直接作用于内存区域，新数据能即刻生效，仅在执行持久化策略时，-例如RDB快照或者AOF日志记录，数据才会异步地或者按需地同步到磁盘，以确保即使在系统重启后数据仍能得以恢复，但此过程并不会妨碍Redis在常规操作中维持其卓越的性能表现。-说到这里，内存资源还是很宝贵的，Redis基于内存操作，它是如何在有限的内存空间中进行精细且高效的内存管理呢？"><a href="#相较于依赖磁盘存储的传统数据库系统，Redis巧妙地运用内存的高速读写特性，显著提高系统的响应速度与整体性能表现。内存相对于磁盘具有无可比拟的读写速度优势。在读取操作层面，Redis无需经过耗时的磁盘IO过程，只需在内存空间内迅速定位所需数据，显著降低访问延迟；而在写入操作时，Redis同样直接作用于内存区域，新数据能即刻生效，仅在执行持久化策略时，-例如RDB快照或者AOF日志记录，数据才会异步地或者按需地同步到磁盘，以确保即使在系统重启后数据仍能得以恢复，但此过程并不会妨碍Redis在常规操作中维持其卓越的性能表现。-说到这里，内存资源还是很宝贵的，Redis基于内存操作，它是如何在有限的内存空间中进行精细且高效的内存管理呢？" class="headerlink" title="相较于依赖磁盘存储的传统数据库系统，Redis巧妙地运用内存的高速读写特性，显著提高系统的响应速度与整体性能表现。内存相对于磁盘具有无可比拟的读写速度优势。在读取操作层面，Redis无需经过耗时的磁盘IO过程，只需在内存空间内迅速定位所需数据，显著降低访问延迟；而在写入操作时，Redis同样直接作用于内存区域，新数据能即刻生效，仅在执行持久化策略时， 例如RDB快照或者AOF日志记录，数据才会异步地或者按需地同步到磁盘，以确保即使在系统重启后数据仍能得以恢复，但此过程并不会妨碍Redis在常规操作中维持其卓越的性能表现。  说到这里，内存资源还是很宝贵的，Redis基于内存操作，它是如何在有限的内存空间中进行精细且高效的内存管理呢？"></a>相较于依赖磁盘存储的传统数据库系统，Redis巧妙地运用内存的高速读写特性，显著提高系统的响应速度与整体性能表现。内存相对于磁盘具有无可比拟的读写速度优势。在读取操作层面，Redis无需经过耗时的磁盘IO过程，只需在内存空间内迅速定位所需数据，显著降低访问延迟；而在写入操作时，Redis同样直接作用于内存区域，新数据能即刻生效，仅在执行持久化策略时， 例如RDB快照或者AOF日志记录，数据才会异步地或者按需地同步到磁盘，以确保即使在系统重启后数据仍能得以恢复，但此过程并不会妨碍Redis在常规操作中维持其卓越的性能表现。  说到这里，内存资源还是很宝贵的，Redis基于内存操作，它是如何在有限的内存空间中进行精细且高效的内存管理呢？</h6><h2 id="过期键删除"><a href="#过期键删除" class="headerlink" title="过期键删除"></a>过期键删除</h2><h3 id="Redis支持为键设置过期时间（TTL）-并且在键过期后会通过两种方式删除它们。"><a href="#Redis支持为键设置过期时间（TTL）-并且在键过期后会通过两种方式删除它们。" class="headerlink" title="Redis支持为键设置过期时间（TTL）,并且在键过期后会通过两种方式删除它们。"></a>Redis支持为键设置过期时间（TTL）,并且在键过期后会通过两种方式删除它们。</h3><ol><li>惰性删除（Lazy Expire):只有当有客户端尝试访问过期键时，Redis才会执行删除操作。优势：避免了不必要的操作，只有在需要时才进行删除。缺点：可能会导致过期键在一段时间内仍占用内存。  </li><li>定期删除（Active Expire):Redis周期性地（默认每10秒）随机抽取一部分键，并检查它们的过期时间。但定期删除会带来额外的CPU消耗。  这两种方式结合，可有效管理和清除过期键，保证Redis的内存使用在合理的范围内。同时，在日常开发中，可以根据业务场景和需求调整过期策略的配置，以达到最佳的性能和内存利用率。</li></ol><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><h6 id="内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的MaxMemory-，Redis会根据预先设置的淘汰策略选择要删除的键，从而释放内存空间。通过合理选择和内存淘汰策略，可以有效管理内存使用，防止内存溢出，并保证系统的稳定性和性能。"><a href="#内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的MaxMemory-，Redis会根据预先设置的淘汰策略选择要删除的键，从而释放内存空间。通过合理选择和内存淘汰策略，可以有效管理内存使用，防止内存溢出，并保证系统的稳定性和性能。" class="headerlink" title="内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的MaxMemory)，Redis会根据预先设置的淘汰策略选择要删除的键，从而释放内存空间。通过合理选择和内存淘汰策略，可以有效管理内存使用，防止内存溢出，并保证系统的稳定性和性能。"></a>内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的MaxMemory)，Redis会根据预先设置的淘汰策略选择要删除的键，从而释放内存空间。通过合理选择和内存淘汰策略，可以有效管理内存使用，防止内存溢出，并保证系统的稳定性和性能。</h6><h6 id="常见的内存淘汰策略："><a href="#常见的内存淘汰策略：" class="headerlink" title="常见的内存淘汰策略："></a>常见的内存淘汰策略：</h6><p>1.LRU(最近最少使用)：LRU策略会删除最近最少被访问的键.Redis会记录每一个键最后一次被访问的时间戳，并定期检查这些时间戳，选择最久未被访问的键进行删除。该策略适合于缓存场景，通常最久未被访问的键可能是最不常用的。<br>2.LFU(最不经常使用)：该策略会删除最不经常被访问的键。该策略适合淘汰访问频率最低的键。<br>3.TTL(键的过期时间):该策略会删除已经过期的键。<br>4.随机删除：该策略会随机选择一些键进行删除。虽然这种策略不考虑键的使用频率和过期时间，但某种情况下可能是简单且有效的淘汰方式，特别是当内存空间不足时。<br>5.淘汰固定数量的键：该策略会选择要删除的键的数量，然后按照一定的规则（LRU,LFU）来选择要淘汰的键。这种淘汰可以保证每次淘汰都释放固定数量的内存空间。<br>当Redis的内存使用达到配置的maxmemory限制时，就会触发内存淘汰策略，以释放内存空间。通过合理配置内存限制和内存淘汰策略，可以有效管理Redis的内存使用，保证系统在内存空间不足时能够及时释放内存，避免因内存溢出导致系统性能下降或者崩溃。</p><blockquote><blockquote><p>修改内存maxmemory只需在redis.conf配置文件中配置maxmemory-policy参数即可。</p></blockquote></blockquote><h2 id="内存碎片管理"><a href="#内存碎片管理" class="headerlink" title="内存碎片管理"></a>内存碎片管理</h2><h6 id="内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。"><a href="#内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。" class="headerlink" title="内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。"></a>内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。</h6><h6 id="为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤："><a href="#为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤：" class="headerlink" title="为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤："></a>为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤：</h6><p>1.<strong>遍历内存空间</strong>：Redis会遍历整个内存空间，检查每个内存块的状态，包括已分配和未分配的内存块。<br>2. <strong>合并相邻的空闲内存块</strong>：Redis会尝试合并相邻的空闲内存块，将它们合并成一个更大的内存块。这样可以减少内存碎片的数量，提高内存利用率。<br>3.<strong>移动数据</strong>：如果有必要，Redis可能会将数据从一个内存块移动到另一个内存块，以便更好地组织内存空间。这个过程可能会比较耗时，因为需要将数据从一个位置复制到另一个位置。<br>4.<strong>释放不再使用的内存块</strong>：最后，Redis会释放那些不再使用的内存块，以便它们可以被重新分配给新的数据。</p><h6 id="通过定期进行碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化程度，提高内存利用率，从而提高系统的性能和稳定性。但是内存碎片整理过程可能会消耗一定的系统资源，尤其是在内存碎片较多的情况下。所以通常情况下，会选择在系统负载较低的情况下进行碎片整理操作，以避免对系统性能产生不利影响。"><a href="#通过定期进行碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化程度，提高内存利用率，从而提高系统的性能和稳定性。但是内存碎片整理过程可能会消耗一定的系统资源，尤其是在内存碎片较多的情况下。所以通常情况下，会选择在系统负载较低的情况下进行碎片整理操作，以避免对系统性能产生不利影响。" class="headerlink" title="通过定期进行碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化程度，提高内存利用率，从而提高系统的性能和稳定性。但是内存碎片整理过程可能会消耗一定的系统资源，尤其是在内存碎片较多的情况下。所以通常情况下，会选择在系统负载较低的情况下进行碎片整理操作，以避免对系统性能产生不利影响。"></a>通过定期进行碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化程度，提高内存利用率，从而提高系统的性能和稳定性。但是内存碎片整理过程可能会消耗一定的系统资源，尤其是在内存碎片较多的情况下。所以通常情况下，会选择在系统负载较低的情况下进行碎片整理操作，以避免对系统性能产生不利影响。</h6>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>本文探讨Redis之所以快速处理大规模数据的原因</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
