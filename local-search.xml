<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2024/04/14/ThreadLocal(3)/"/>
    <url>/2024/04/14/ThreadLocal(3)/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal-常见使用场景"><a href="#ThreadLocal-常见使用场景" class="headerlink" title="ThreadLocal 常见使用场景"></a>ThreadLocal 常见使用场景</h3>]]></content>
    
    
    <categories>
      
      <category>多线程与并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈Threadlocal（3）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2024/04/14/ThreadLocal(2)/"/>
    <url>/2024/04/14/ThreadLocal(2)/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal原理（源码分析）"><a href="#ThreadLocal原理（源码分析）" class="headerlink" title="ThreadLocal原理（源码分析）"></a>ThreadLocal原理（源码分析）</h3><ol><li>ThreadLocal的set方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span>&#123;<br>    <span class="hljs-comment">//1.获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//2. 获取线程中的属性threadLocalMap,若threadLocalMap不为空，则直接更新要保存的变量值；</span><br>    <span class="hljs-comment">//否则创建threadLocalMap，并赋值。</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span>(map != <span class="hljs-literal">null</span>)&#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-comment">//初始化threadLocalMap 并赋值</span><br>      creatMap(t, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>从上面代码可知，ThreadLocal set赋值时首先会获取当前线程thread,并获取thread线程中的threadLocalMap属性。如果map属性不为空，则直接更新value值，如果为空，则实例化threadLocalMap，并赋值。</li></ol><p>接下来分析一下 threadLocalMap 和 createMap 的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br> <br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * The entries in this hash map extend WeakReference, using</span><br><span class="hljs-comment">       * its main ref field as the key (which is always a</span><br><span class="hljs-comment">       * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="hljs-comment">       * == null) mean that the key is no longer referenced, so the</span><br><span class="hljs-comment">       * entry can be expunged from table.  Such entries are referred to</span><br><span class="hljs-comment">       * as &quot;stale entries&quot; in the code that follows.</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>          <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>          Object value;<br> <br>          Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>              <span class="hljs-built_in">super</span>(k);<br>              value = v;<br>          &#125;<br>      &#125;<br> <br>      <br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看出 ThreadLocalMap是 ThreadLocal的静态类，它的构成主要用Entry来保存数据，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个是threadlocal 的内部方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>        t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>    &#125;<br> <br> <br>    <span class="hljs-comment">//ThreadLocalMap 构造方法</span><br>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>            table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>            table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>            size = <span class="hljs-number">1</span>;<br>            setThreshold(INITIAL_CAPACITY);<br>        &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>ThreadLocal的get方法： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-comment">//1. 获取当前线程</span><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>   <span class="hljs-comment">//2. 获取当前线程的ThreadLocalMap</span><br>   <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>   <span class="hljs-comment">//3. 如果map不为空</span><br>   <span class="hljs-keyword">if</span>(map != <span class="hljs-literal">null</span>)&#123;<br>       <span class="hljs-comment">//获取ThreadLocalMap中存储的值</span><br>       ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>       <span class="hljs-keyword">if</span>(e != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>           <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>           <span class="hljs-keyword">return</span> result;<br>       &#125;<br>   &#125; <br>   <span class="hljs-comment">//如果数据为null,则初始化，初始化结果，ThreadLocalMap中存放key值为ThreadLocal,值为null</span><br>   <span class="hljs-keyword">return</span> setInitialValue();<br><br>   <span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>       <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>       <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>           map.set(<span class="hljs-built_in">this</span>, value);<br>       <span class="hljs-keyword">else</span><br>           createMap(t, value);<br>       <span class="hljs-keyword">return</span> value;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>ThreadLocal的remove方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span>(m != <span class="hljs-literal">null</span>)&#123;<br>        m.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><strong>remove方法，直接将ThreadLocal对应的值从当前线程Thread中ThreadLocalMap中删除。为何删除，这涉及内存泄漏 （memory leak，指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。）的问题。</strong><br> 实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</li></ol><p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p><p>ThreadLocal其实是与线程绑定的一个变量，如此就会出现一个问题：如果没有将ThreadLocal内的变量删除（remove）或替换，它的生命周期将会与线程共存。通常线程池中对线程管理都是采用线程复用的方法，在线程池中线程很难结束甚至于永远不会结束，这将意味着线程持续的时间将不可预测，甚至与JVM的生命周期一致。举个例字，如果ThreadLocal中直接或间接包装了集合类或复杂对象，每次在同一个ThreadLocal中取出对象后，再对内容做操作，那么内部的集合类和复杂对象所占用的空间可能会开始持续膨胀。</p><h4 id="ThreadLocal与Thread，ThreadLocalMap之间的关系"><a href="#ThreadLocal与Thread，ThreadLocalMap之间的关系" class="headerlink" title="ThreadLocal与Thread，ThreadLocalMap之间的关系"></a>ThreadLocal与Thread，ThreadLocalMap之间的关系</h4><p><img src="/source/images/3.png"><br><img src="/source/images/4.png"><br>从这个图中我们可以非常直观的看出，ThreadLocalMap其实是Thread线程的一个属性值，而ThreadLocal是维护ThreadLocalMap这个属性值的一个工具类。<mark>Thread线程可以拥有多个ThreadLocal维护的自己线程独享的共享变量</mark>（这个共享变量只是针对自己线程里面共享）</p>]]></content>
    
    
    <categories>
      
      <category>多线程与并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈Threadlocal（2）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2024/04/13/ThreadLocal/"/>
    <url>/2024/04/13/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h3><h4 id="ThreadLocal-线程变量-，意思是ThreadLocal中填充的变量属于当前线程。该变量对其他线而言是隔离的，该变量是当前线程的独有变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。"><a href="#ThreadLocal-线程变量-，意思是ThreadLocal中填充的变量属于当前线程。该变量对其他线而言是隔离的，该变量是当前线程的独有变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。" class="headerlink" title="ThreadLocal  (线程变量)，意思是ThreadLocal中填充的变量属于当前线程。该变量对其他线而言是隔离的，该变量是当前线程的独有变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。"></a>ThreadLocal <mark> (线程变量)</mark>，意思是ThreadLocal中填充的变量属于当前线程。该变量对其他线而言是隔离的，该变量是当前线程的独有变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</h4><p>ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：</p><ol><li>因为每个 Thread 内有自己的实例副本，且<mark>该副本只能由当前 Thread 使用</mark>。这是也是 ThreadLocal 命名的由来。</li><li>既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就<mark>不存在多线程间共享的问题</mark>。</li><li>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</li></ol><h4 id="总的来说，ThreadLocal-适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景"><a href="#总的来说，ThreadLocal-适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景" class="headerlink" title="总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景."></a>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景.</h4><p>下图是ThreadLocal在使用过程中的状态：<br><img src="/source/images/1.png"></p><h3 id="ThreadLocal与Synchronized的区别"><a href="#ThreadLocal与Synchronized的区别" class="headerlink" title="ThreadLocal与Synchronized的区别"></a>ThreadLocal与Synchronized的区别</h3><p>ThreadLocal<T>其实是与线程绑定的一个变量。ThreadLocal和Synchonized都用于解决多线程并发访问。</p><p>ThreadLocal与Synchronized本质区别在于： </p><ol><li>Synchronized用于线程间的数据共享，而ThreadLocal用于线程间的数据隔离。</li><li>Synchronized利用锁机制，使变量或代码块在某一时刻只能被一个线程访问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的共享。而Synchronized却正好相反，用于在多个线程间通信是数据共享。</li></ol><p><em><strong>一句话理解ThreadLocal，threadlocl是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry（threadlocl,value），虽然不同的线程之间threadlocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二的，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程中这个value变量地址是一样的。</strong></em></p><h3 id="ThreadLocal的简单使用"><a href="#ThreadLocal的简单使用" class="headerlink" title="ThreadLocal的简单使用"></a>ThreadLocal的简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocaDemo</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;String&gt;();<br> <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">//打印当前线程中本地内存中本地变量的值</span><br>        System.out.println(str + <span class="hljs-string">&quot; :&quot;</span> + localVar.get());<br>        <span class="hljs-comment">//清除本地内存中的本地变量</span><br>        localVar.remove();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br> <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                ThreadLocaDemo.localVar.set(<span class="hljs-string">&quot;local_A&quot;</span>);<br>                print(<span class="hljs-string">&quot;A&quot;</span>);<br>                <span class="hljs-comment">//打印本地变量</span><br>                System.out.println(<span class="hljs-string">&quot;after remove : &quot;</span> + localVar.get());<br>               <br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br> <br>        Thread.sleep(<span class="hljs-number">1000</span>);<br> <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                ThreadLocaDemo.localVar.set(<span class="hljs-string">&quot;local_B&quot;</span>);<br>                print(<span class="hljs-string">&quot;B&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;after remove : &quot;</span> + localVar.get());<br>              <br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br>&#125;<br> <br>A :local_A<br>after remove : <span class="hljs-literal">null</span><br>B :local_B<br>after remove : <span class="hljs-literal">null</span><br> <br></code></pre></td></tr></table></figure><p>从该示例中，两个线程分别获取自己线程存放的变量，变量获取不会错乱。</p>]]></content>
    
    
    <categories>
      
      <category>多线程与并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈Threadlocal（1）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/13/hello-world/"/>
    <url>/2024/04/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Redis为何那么快（一）</title>
    <link href="/2024/03/29/%E6%B5%85%E8%B0%88Redis%E4%B8%BA%E4%BD%95%E9%82%A3%E4%B9%88%E5%BF%AB/"/>
    <url>/2024/03/29/%E6%B5%85%E8%B0%88Redis%E4%B8%BA%E4%BD%95%E9%82%A3%E4%B9%88%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="我们从Redis基于内存操作的特性、高效的内存数据结构、单线程模型、I-O多路复用技术、底层模型和优化技术、持久化机制以及网络通信协议等多个方面进行分析和讨论。通过深入了解Redis内部机制和性能优化技术，我们可以更好地理解Redis之所以快速地根本原因＋在实际应用中发挥其优势。"><a href="#我们从Redis基于内存操作的特性、高效的内存数据结构、单线程模型、I-O多路复用技术、底层模型和优化技术、持久化机制以及网络通信协议等多个方面进行分析和讨论。通过深入了解Redis内部机制和性能优化技术，我们可以更好地理解Redis之所以快速地根本原因＋在实际应用中发挥其优势。" class="headerlink" title="我们从Redis基于内存操作的特性、高效的内存数据结构、单线程模型、I&#x2F;O多路复用技术、底层模型和优化技术、持久化机制以及网络通信协议等多个方面进行分析和讨论。通过深入了解Redis内部机制和性能优化技术，我们可以更好地理解Redis之所以快速地根本原因＋在实际应用中发挥其优势。"></a>我们从Redis基于内存操作的特性、高效的内存数据结构、单线程模型、I&#x2F;O多路复用技术、底层模型和优化技术、持久化机制以及网络通信协议等多个方面进行分析和讨论。通过深入了解Redis内部机制和性能优化技术，我们可以更好地理解Redis之所以快速地根本原因＋在实际应用中发挥其优势。</h4><p><img src="/source/images/2.png"></p><h1 id="完全基于内存"><a href="#完全基于内存" class="headerlink" title="&#x3D;&#x3D;完全基于内存&#x3D;&#x3D;"></a>&#x3D;&#x3D;完全基于内存&#x3D;&#x3D;</h1><h6 id="相较于依赖磁盘存储的传统数据库系统，Redis巧妙地运用内存的高速读写特性，显著提高系统的响应速度与整体性能表现。内存相对于磁盘具有无可比拟的读写速度优势。在读取操作层面，Redis无需经过耗时的磁盘IO过程，只需在内存空间内迅速定位所需数据，显著降低访问延迟；而在写入操作时，Redis同样直接作用于内存区域，新数据能即刻生效，仅在执行持久化策略时，-例如RDB快照或者AOF日志记录，数据才会异步地或者按需地同步到磁盘，以确保即使在系统重启后数据仍能得以恢复，但此过程并不会妨碍Redis在常规操作中维持其卓越的性能表现。-说到这里，内存资源还是很宝贵的，Redis基于内存操作，它是如何在有限的内存空间中进行精细且高效的内存管理呢？"><a href="#相较于依赖磁盘存储的传统数据库系统，Redis巧妙地运用内存的高速读写特性，显著提高系统的响应速度与整体性能表现。内存相对于磁盘具有无可比拟的读写速度优势。在读取操作层面，Redis无需经过耗时的磁盘IO过程，只需在内存空间内迅速定位所需数据，显著降低访问延迟；而在写入操作时，Redis同样直接作用于内存区域，新数据能即刻生效，仅在执行持久化策略时，-例如RDB快照或者AOF日志记录，数据才会异步地或者按需地同步到磁盘，以确保即使在系统重启后数据仍能得以恢复，但此过程并不会妨碍Redis在常规操作中维持其卓越的性能表现。-说到这里，内存资源还是很宝贵的，Redis基于内存操作，它是如何在有限的内存空间中进行精细且高效的内存管理呢？" class="headerlink" title="相较于依赖磁盘存储的传统数据库系统，Redis巧妙地运用内存的高速读写特性，显著提高系统的响应速度与整体性能表现。内存相对于磁盘具有无可比拟的读写速度优势。在读取操作层面，Redis无需经过耗时的磁盘IO过程，只需在内存空间内迅速定位所需数据，显著降低访问延迟；而在写入操作时，Redis同样直接作用于内存区域，新数据能即刻生效，仅在执行持久化策略时， 例如RDB快照或者AOF日志记录，数据才会异步地或者按需地同步到磁盘，以确保即使在系统重启后数据仍能得以恢复，但此过程并不会妨碍Redis在常规操作中维持其卓越的性能表现。  说到这里，内存资源还是很宝贵的，Redis基于内存操作，它是如何在有限的内存空间中进行精细且高效的内存管理呢？"></a>相较于依赖磁盘存储的传统数据库系统，Redis巧妙地运用内存的高速读写特性，显著提高系统的响应速度与整体性能表现。内存相对于磁盘具有无可比拟的读写速度优势。在读取操作层面，Redis无需经过耗时的磁盘IO过程，只需在内存空间内迅速定位所需数据，显著降低访问延迟；而在写入操作时，Redis同样直接作用于内存区域，新数据能即刻生效，仅在执行持久化策略时， 例如RDB快照或者AOF日志记录，数据才会异步地或者按需地同步到磁盘，以确保即使在系统重启后数据仍能得以恢复，但此过程并不会妨碍Redis在常规操作中维持其卓越的性能表现。  说到这里，内存资源还是很宝贵的，Redis基于内存操作，它是如何在有限的内存空间中进行精细且高效的内存管理呢？</h6><h2 id="过期键删除"><a href="#过期键删除" class="headerlink" title="过期键删除"></a>过期键删除</h2><h3 id="Redis支持为键设置过期时间（TTL）-并且在键过期后会通过两种方式删除它们。"><a href="#Redis支持为键设置过期时间（TTL）-并且在键过期后会通过两种方式删除它们。" class="headerlink" title="Redis支持为键设置过期时间（TTL）,并且在键过期后会通过两种方式删除它们。"></a>Redis支持为键设置过期时间（TTL）,并且在键过期后会通过两种方式删除它们。</h3><ol><li>惰性删除（Lazy Expire):只有当有客户端尝试访问过期键时，Redis才会执行删除操作。优势：避免了不必要的操作，只有在需要时才进行删除。缺点：可能会导致过期键在一段时间内仍占用内存。  </li><li>定期删除（Active Expire):Redis周期性地（默认每10秒）随机抽取一部分键，并检查它们的过期时间。但定期删除会带来额外的CPU消耗。  这两种方式结合，可有效管理和清除过期键，保证Redis的内存使用在合理的范围内。同时，在日常开发中，可以根据业务场景和需求调整过期策略的配置，以达到最佳的性能和内存利用率。</li></ol><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><h6 id="内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的MaxMemory-，Redis会根据预先设置的淘汰策略选择要删除的键，从而释放内存空间。通过合理选择和内存淘汰策略，可以有效管理内存使用，防止内存溢出，并保证系统的稳定性和性能。"><a href="#内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的MaxMemory-，Redis会根据预先设置的淘汰策略选择要删除的键，从而释放内存空间。通过合理选择和内存淘汰策略，可以有效管理内存使用，防止内存溢出，并保证系统的稳定性和性能。" class="headerlink" title="内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的MaxMemory)，Redis会根据预先设置的淘汰策略选择要删除的键，从而释放内存空间。通过合理选择和内存淘汰策略，可以有效管理内存使用，防止内存溢出，并保证系统的稳定性和性能。"></a>内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的MaxMemory)，Redis会根据预先设置的淘汰策略选择要删除的键，从而释放内存空间。通过合理选择和内存淘汰策略，可以有效管理内存使用，防止内存溢出，并保证系统的稳定性和性能。</h6><h6 id="常见的内存淘汰策略："><a href="#常见的内存淘汰策略：" class="headerlink" title="常见的内存淘汰策略："></a>常见的内存淘汰策略：</h6><p>1.LRU(最近最少使用)：LRU策略会删除最近最少被访问的键.Redis会记录每一个键最后一次被访问的时间戳，并定期检查这些时间戳，选择最久未被访问的键进行删除。该策略适合于缓存场景，通常最久未被访问的键可能是最不常用的。<br>2.LFU(最不经常使用)：该策略会删除最不经常被访问的键。该策略适合淘汰访问频率最低的键。<br>3.TTL(键的过期时间):该策略会删除已经过期的键。<br>4.随机删除：该策略会随机选择一些键进行删除。虽然这种策略不考虑键的使用频率和过期时间，但某种情况下可能是简单且有效的淘汰方式，特别是当内存空间不足时。<br>5.淘汰固定数量的键：该策略会选择要删除的键的数量，然后按照一定的规则（LRU,LFU）来选择要淘汰的键。这种淘汰可以保证每次淘汰都释放固定数量的内存空间。<br>当Redis的内存使用达到配置的maxmemory限制时，就会触发内存淘汰策略，以释放内存空间。通过合理配置内存限制和内存淘汰策略，可以有效管理Redis的内存使用，保证系统在内存空间不足时能够及时释放内存，避免因内存溢出导致系统性能下降或者崩溃。</p><blockquote><blockquote><p>修改内存maxmemory只需在redis.conf配置文件中配置maxmemory-policy参数即可。</p></blockquote></blockquote><h2 id="内存碎片管理"><a href="#内存碎片管理" class="headerlink" title="内存碎片管理"></a>内存碎片管理</h2><h6 id="内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。"><a href="#内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。" class="headerlink" title="内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。"></a>内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。</h6><h6 id="为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤："><a href="#为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤：" class="headerlink" title="为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤："></a>为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤：</h6><p>1.遍历内存空间：Redis会遍历整个内存空间，检查每个内存块的状态，包括已分配和未分配的内存块。<br>2.合并相邻的空闲内存块：Redis会尝试合并相邻的空闲内存块，将它们合并成一个更大的内存块。这样可以减少内存碎片的数量，提高内存利用率。<br>3.移动数据：如果有必要，Redis可能会将数据从一个内存块移动到另一个内存块，以便更好地组织内存空间。这个过程可能会比较耗时，因为需要将数据从一个位置复制到另一个位置。<br>4.释放不再使用的内存块：最后，Redis会释放那些不再使用的内存块，以便它们可以被重新分配给新的数据。</p><h6 id="通过定期进行碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化程度，提高内存利用率，从而提高系统的性能和稳定性。但是内存碎片整理过程可能会消耗一定的系统资源，尤其是在内存碎片较多的情况下。所以通常情况下，会选择在系统负载较低的情况下进行碎片整理操作，以避免对系统性能产生不利影响。"><a href="#通过定期进行碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化程度，提高内存利用率，从而提高系统的性能和稳定性。但是内存碎片整理过程可能会消耗一定的系统资源，尤其是在内存碎片较多的情况下。所以通常情况下，会选择在系统负载较低的情况下进行碎片整理操作，以避免对系统性能产生不利影响。" class="headerlink" title="通过定期进行碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化程度，提高内存利用率，从而提高系统的性能和稳定性。但是内存碎片整理过程可能会消耗一定的系统资源，尤其是在内存碎片较多的情况下。所以通常情况下，会选择在系统负载较低的情况下进行碎片整理操作，以避免对系统性能产生不利影响。"></a>通过定期进行碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化程度，提高内存利用率，从而提高系统的性能和稳定性。但是内存碎片整理过程可能会消耗一定的系统资源，尤其是在内存碎片较多的情况下。所以通常情况下，会选择在系统负载较低的情况下进行碎片整理操作，以避免对系统性能产生不利影响。</h6>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>本文探讨Redis之所以快速处理大规模数据的原因</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
