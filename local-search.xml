<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>IO多路复用之epoll的原理与使用 + Reactor模型解析</title>
    <link href="/2025/11/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2025/11/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="IO多路复用之epoll的原理与使用-Reactor模型解析"><a href="#IO多路复用之epoll的原理与使用-Reactor模型解析" class="headerlink" title="IO多路复用之epoll的原理与使用 + Reactor模型解析"></a>IO多路复用之epoll的原理与使用 + Reactor模型解析</h2><h3 id="IO复用：在复用什么？"><a href="#IO复用：在复用什么？" class="headerlink" title="IO复用：在复用什么？"></a>IO复用：在复用什么？</h3><p>IO复用使得程序可以同时监听多个文件描述符，<strong>复用的是线程&#x2F;进程</strong>，而非连接本身。让一个线程（进）同时监听成百上千个网络连接（文件描述符），只在某个连接真正可读&#x2F;可写时，才处理该连接。</p><h3 id="IO复用使用场景"><a href="#IO复用使用场景" class="headerlink" title="IO复用使用场景"></a>IO复用使用场景</h3><ol><li>客户端程序同时处理多个socket(非阻塞connect技术)</li><li>客户端程序同时处理用户输入与网络连接（聊天室）</li><li>TCP服务器程序同时处理监听socket和连接socket</li><li>服务器同时处理TCP UDP请求（回射服务器）</li><li>服务器同时监听多个端口，或者处理多种服务</li></ol><p>需要注意的是，IO复用虽然能同时监听多个网络连接，但是<strong>其本身是阻塞的</strong>，并且当多个文件描述符就绪时，如果不采用额外的措施，程序就只能依次按顺序处理文件描述符。这使得服务器程序看上去像是串行在工作。若要实现并发，要采用多进程&#x2F;多线程等编程手段。</p><p>(之后，我会去聊聊 多线程&#x2F;多进程的协作方式  参考blog：多线程&#x2F;多进程的协作方式 )</p><h3 id="epoll原理："><a href="#epoll原理：" class="headerlink" title="epoll原理："></a>epoll原理：</h3><ol><li><p>内核事件表：<br>首先，epoll使用一组函数来完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符事实上的事件都放入内核中的一个事件表里，从而无需像select poll那样，每次调用都需要重复传入文件描述符集或事件集。但epoll需要一个额外的文件描述符，来<strong>唯一标识内核中的这个事件表</strong>。这个文件描述符使用<strong>epoll_create()</strong> 函数创建:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br></code></pre></td></tr></table></figure><p>size参数：告诉内核，事件表需要多大。该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。<br>epoll_ctl()用来操作epoll的内核事件表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>;<br></code></pre></td></tr></table></figure><p>fd参数：要操作的文件描述符<br>op参数：操作类型</p><ul><li>操作类型：<br>EPOLL_CTL_ADD：添加文件描述符到内核事件表<br>EPOLL_CTL_MOD：修改文件描述符在内核事件表中的属性<br>EPOLL_CTL_DEL：从内核事件表中删除文件描述符</li></ul><p>event参数：指定事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br>  _uint32 events;  <span class="hljs-comment">/* epoll 事件 */</span><br>  epoll_data data; <span class="hljs-comment">/* 用户数据 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>events参数：描述事件类型， epoll有两个额外的事件类型-EPOLLET和EPOLLONESHOT，它们对于epoll的高效运作非常关键。 后面讲一下EPOLLONESHOT</p></li><li><p>epoll_wait()<br>epoll系列系统调用的主要接口。<strong>它在一段超时时间内等待一组文件描述符上的事件。</strong><br>原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents,</span><br><span class="hljs-params"><span class="hljs-type">int</span> timeout)</span><br></code></pre></td></tr></table></figure><p>该函数成功时返回已就绪的文件描述符个数，失败时返回-1，并设置errno<br>重点参数解析：</p><ul><li>maxevents参数：指定最多监听的事件数</li><li>epoll_wait()如果检测到事件，就将所有就绪的事件从内核事件表（由epfd参数指定）中复制到events参数指定的数组中。</li><li>重点：events参数：这个数组只用于输出epoll_wait()检测到的就绪事件，不想poll select的数组参数那样，既用于传入用户注册的事件，也用于输出内核检测到的就绪事件。(简单说，就是epoll的events数组里放的正好就是就绪了的文件描述符，都是能用的) 这就<strong>极大提高了应用程序索引就绪文件描述符的效率</strong>。<br>来看下 poll 和 epoll在使用上的区别 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 如何索引poll返回的就绪文件描述符 */</span><br><span class="hljs-type">int</span> ret = poll(fds, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br><span class="hljs-comment">/* 必须遍历所有的已注册的文件描述符并找到其中的就绪者 */</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; MAX_EVENT_NUMBER; i++ &#123;<br>  <span class="hljs-keyword">if</span> (fds[i].revents &amp; POLLIN)&#123; <span class="hljs-comment">// 判断第i个可读的就绪事件</span><br>      <span class="hljs-type">int</span> socketfd = fds[i].fd;<br>      <span class="hljs-comment">// 处理socketfd</span><br>      ...<br>  &#125;<br>&#125; <br><br><span class="hljs-comment">/* 如何索引epoll返回的就绪文件描述符 */</span><br><span class="hljs-type">int</span> ret = epoll_wait(epfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br><span class="hljs-comment">/* 仅遍历就绪ret个文件描述符 */</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++ &#123;<br>      <span class="hljs-type">int</span> socketfd = events[i].data.fd;<br>      <span class="hljs-comment">// 处理socketfd</span><br>      ...<br>&#125; <br></code></pre></td></tr></table></figure></li></ul></li><li><p>LT vs ET模式<br>   LT是默认的工作模式，<strong>当往epoll的内核事件表中注册一个文件描述符上的EPOLLET事件时</strong>，表示epoll将以ET模式操作文件描述符。**(ET模式下事件被触发的次数少于LT)**</p></li></ol><ul><li>LT模式：只要还有数据可读&#x2F;写，就一直提醒你处理</li><li>ET模式：只在数据刚到&#x2F;状态变化时提醒一次，就提醒你处理一次，没处理完也不会再喊你<br>   <strong>！注意：Q: 为何ET用非阻塞socket</strong><br>   A：如果文件描述符是阻塞的，那么读或写操作将会因为没有后续事件而一直处于阻塞状态（饥渴状态）</li><li>ET（边缘触发）模式下，如果文件描述符仍保持阻塞属性，会出现两个致命问题：<ol><li>   数据可能“卡死”在内核缓冲区<br>ET 只在状态变化时通知一次。假设内核缓冲区里有 2048 字节，应用只读了 1024 字节就返回，剩余数据会一直留在缓冲区。由于 ET 不会再次触发可读事件，应用就再也收不到后续通知，数据就此“饿死”。</li><li>   单次读写操作可能永久阻塞<br>若描述符是阻塞的，当应用试图一次性读完所有数据时，最后一次 read&#x2F;write 会因缓冲区暂时空&#x2F;满而挂起，线程被牢牢锁死，无法继续处理其他就绪 fd，导致整个事件循环停滞。</li></ol></li></ul><ol start="4"><li><p>EPOLLONESHOT事件<br>假设使用ET模式，还是有可能一个socket上的事件被多次触发，这在并发程序中会造成问题。比如说，一个线程&#x2F;进程先处理了一个socket，后续该socket又有新的数据可是读写（EPOLLIN再次被触发），此时另外的线程会被唤醒来读取这些新数据。从而变成多个线程同时操作同一个socket的局面，这显然不是我们愿意看到的。<br>EPOLLONESHOT事件<strong>用于解决这个问题</strong>， <strong>一个socket在任一时刻都只能被一个线程处理。</strong><br>简单概括下工作原理，我们注册EPOLLONSHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且触发一次。除非用epoll_ctl()重置该文件描述符上注册的EPOLLONESHOT事件。但同时，如果该socket之后还有新的任务需要被重新处理，你应该在之前的线程中立即重置该socket上的EPOLLONESHOT事件。</p><ul><li>总结：一个socket可以被多个线程不同时处理， 但我们保证同一时间，一个socket只能被一个线程处理。从而保证连接的完整性，避免很多的竞态条件。</li></ul></li></ol><p>go这里，更多采用net + Goroutine来实现类Reactor模型的Echo Server，底层自动使用epoll(Linux)<br>简单看个epoll echo server 的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(c net.Conn)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> c.Close()<br>    <span class="hljs-keyword">defer</span> wg.Done()<br><br>    reader := bufio.NewReader(c)<br>    <span class="hljs-keyword">for</span> &#123;<br>        message, err := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">//客户端断开连接</span><br>            log.Printf(<span class="hljs-string">&quot;client %s disconnected&quot;</span>, c.RemoteAddr())<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        log.Printf(<span class="hljs-string">&quot;Received from %s: %q&quot;</span>, c.RemoteAddr(), message)<br>        <span class="hljs-comment">// Echo back to client</span><br>        err := c.Write([]<span class="hljs-type">byte</span>(message))<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>    listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(<span class="hljs-string">&quot;Listen failed:&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> listen.Close()<br><br>    <span class="hljs-keyword">for</span>&#123;<br>        conn, err := listen.Accept()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>           log.Fatal(<span class="hljs-string">&quot;Accept failed:&quot;</span>, err)<br>           <span class="hljs-keyword">continue</span><br>        &#125;<br>        log.Printf(<span class="hljs-string">&quot;New client connected: %s&quot;</span>, conn.RemoteAddr())<br><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> handleConn(conn)<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TODO 有空会去分析下go runtime库下的netpoll，对linux epoll的封装</p><h3 id="select-poll-epoll-对比"><a href="#select-poll-epoll-对比" class="headerlink" title="select poll epoll 对比"></a>select poll epoll 对比</h3><ul><li>找就绪文件描述符方式不同：select poll 轮询， epoll 回调</li><li>LT ET选择模式不同：select poll LT， epoll 可选择ET模式，并且还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写或异常等事件被触发的次数</li><li>但是当活动连接比较多的时候，epoll效率不一定比select poll高，原因在于此时回调函数被触发的过于频繁（回调函数将该就绪的文件描述符上对应的事件插入到内核就绪事件队列）。</li><li>适用场景：epoll适用于大并发场景，连接数比较多，但活动连接数比较少</li></ul><p><img src="/images/23.jpg"></p><h2 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h2><h3 id="Reactor模型思想："><a href="#Reactor模型思想：" class="headerlink" title="Reactor模型思想："></a>Reactor模型思想：</h3><p>总结：事件驱动 + 非阻塞IO + <strong>少量连接支持大量并发</strong><br>IO分为两个阶段：</p><ul><li>监听：用IO多路复用（epoll &#x2F; hqueue等）把所有待处理的连接&#x2F;文件描述符统一监控，一旦某个描述符就绪（可读&#x2F;可写&#x2F;异常），立即触发事件。</li><li>分发：事件循环（Reactor线程）拿到就绪事件后，把它分发到预先注册的事件处理器（Handler），由Handler完成实际的数据处理。</li><li>! 简单理解 : Reactor 负责 “发现事件并派活” -&gt;  Handler 负责 “干活”，处理完立即返回，避免阻塞事件循环 -&gt; 如果业务逻辑耗时，可把任务扔进线程池异步处理，让主线程继续监听新事件。</li></ul><h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul><li>核心区别在于：数据处理阶段</li><li>Reactor: 同步非阻塞 Proactor: 异步非阻塞</li><li>Reactor: 就绪通知 Proactor: 完成通知</li><li>Reactor: IO操作由应用完成  Proactor: IO操作由内核处理</li><li>Reactor: Linux(epoll) 和 Windows(IOCP)均可实现  Proactor: 需要操作系统支持异步IO Windows(IOCP) </li><li>使用场景： Reactor: 跨平台 短链接 业务逻辑轻 Proactor: 大文件&#x2F;视频 极致吞吐 Windows高性能服务 可接受较高复杂度</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>Linux高性能服务器编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>服务器编程</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何避免惊群问题？(SO_REUSEPORT)</title>
    <link href="/2025/11/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2025/11/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="如何避免惊群问题？-SO-REUSEPORT"><a href="#如何避免惊群问题？-SO-REUSEPORT" class="headerlink" title="如何避免惊群问题？(SO_REUSEPORT)"></a>如何避免惊群问题？(SO_REUSEPORT)</h3>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>Linux高性能服务器编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>服务器编程</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TIME_WAIT问题，以及如何优化/解决？</title>
    <link href="/2025/11/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2025/11/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="TIME-WAIT问题，以及如何优化-解决？"><a href="#TIME-WAIT问题，以及如何优化-解决？" class="headerlink" title="TIME_WAIT问题，以及如何优化&#x2F;解决？"></a>TIME_WAIT问题，以及如何优化&#x2F;解决？</h3><h4 id="何时出现TIME-WAIT"><a href="#何时出现TIME-WAIT" class="headerlink" title="何时出现TIME_WAIT"></a>何时出现TIME_WAIT</h4><p><img src="/images/24.jpg"><br>从上图可以看到，在客户端收到服务端发过来的报文段6后，客户端进入TIME_WAIT状态，这个状态的持续时间为2MSL。<br>TIME_WAIT存在的原因有以下两点：</p><ul><li>可靠地终止TCP连接</li><li>保证让迟来地TCP报文段有足够地时间被识别并丢弃（或者说 避免历史报文被新的连接接收 ）</li></ul><h4 id="TIME-WAIT持续时间"><a href="#TIME-WAIT持续时间" class="headerlink" title="TIME_WAIT持续时间"></a>TIME_WAIT持续时间</h4><p>2MSL ，MSL表示最大 segments lifetime ，即TCP报文段最大的生命期。<br>坚持2MSL时间，是为了保证网络两个传输方向上尚未被接收到、迟到地tcp报文段都已经消失（被中转路由器丢弃）。</p><h4 id="如何解决（避免）TIME-WAIT"><a href="#如何解决（避免）TIME-WAIT" class="headerlink" title="如何解决（避免）TIME_WAIT"></a>如何解决（避免）TIME_WAIT</h4><p><img src="/images/25.jpg"><br>使用netstat查看连接状态，可以看到，客户端程序被中断后，连接进入TIME_WAIT状态，12345端口被占用，所以客户端重启失败。</p><ul><li>事实是，这个例子是我们指定了端口，所以重启失败。客户端程序不用担心这个问题。<strong>因为客户端一般使用系统自动分配的临时端口号来建立连接，而由于随机性</strong>，临时端口号一般和上次使用的端口号不同，所以一般客户端可以重启成功。</li><li>针对于服务器程序，因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即重启。解决方案：通过socket选项SO_REUSEADDR，允许端口复用。(强制进程立即使用处于TIME_WAIT状态的连接占用的端口)</li><li>总结： <ol><li>客户端程序主动断连接</li><li>如果是客户端这边有大量time_wait状态的连接，考虑开启tcp_tw_reuse参数，复用time_wait超过1秒的连接。<br><strong>ps</strong>: 上文说到：“因为客户端一般使用系统自动分配的临时端口号来建立连接，而由于随机性**，临时端口号一般和上次使用的端口号不同，所以一般客户端可以重启成功。” 那是不是就代表不开启tcp_tw_reuse参数,也可以?<br><strong>回答</strong>： 一般情况是这样的。但是当客户端这边压测服务器，大量并发就会导致连接不够用；且一般情况下，服务器会使用nginx反向代理，那么nginx相对于服务器，就是客户端，那么nginx肯定是要开这个参数的，否则连接无法复用。</li><li>服务端这边，尽量把断开连接的主动权交给客户端。</li><li>服务端断，通过socket选项SO_REUSEADDR，允许端口复用</li></ol></li></ul><p>ps: 需要注意的是，SO_REUSEADDR是用于解决TIME_WAIT状态导致的连接无法使用的问题，（解决的是服务端启动时，总是报Address already in use的错误）但不是解决TIME_WAIT状态的。详情参见：<a href="https://xiaolincoding.com/network/3_tcp/port.html#%E5%A4%9A%E4%B8%AA-tcp-%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97">https://xiaolincoding.com/network/3_tcp/port.html#%E5%A4%9A%E4%B8%AA-tcp-%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97</a></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>Linux高性能服务器编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>服务器编程</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程/进程协作方式</title>
    <link href="/2025/11/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2025/11/19/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h2><ul><li>复制进程映像的fork系统调用，替换进程映像的exec系统调用</li><li>僵尸进程以及如何避免僵尸进程</li><li>进程间通信方式（Inter-Process Communication，IPC）最最简单的方式：管道</li><li>3种System V 进程间通信方式：共享内存、消息队列、信号量</li></ul><h4 id="fork系统调用"><a href="#fork系统调用" class="headerlink" title="fork系统调用"></a>fork系统调用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>该函数每次调用都返回两次，在父进程中返回子进程的进程PID，在子进程中则返回0。该返回值是后续代码判断当前进程是主还是子进程的依据。<br>子进程代码与父进程的完全相同，同时它还会复制父进程的数据（栈、堆、静态数据）。同时复制采用<strong>写时复制</strong>（COW）即只有在任一进程（父&#x2F;子）对数据执行了写操作时，复制才会发生（<strong>先是缺页中断，然后操作系统给子进程分配内存并复制父进程的数据）</strong></p><h4 id="处理僵尸进程"><a href="#处理僵尸进程" class="headerlink" title="处理僵尸进程"></a>处理僵尸进程</h4><p>僵尸态：<br>   前提：对于多进程程序而言，父进程一般需要跟踪子进程的退出状态。因此，子进程结束运行时，内核不会立即释放该进程的进程表表项，以满足父进程后续对子进程退出信息的查询（如果父进程还在查询）。</p><ol><li>在子进程结束运行之后，父进程读取其退出状态之前，该子进程处于僵尸态</li><li>父进程结束或异常终止，而子进程继续运行，该子进程处于僵尸态</li></ol><p>  无论何种情况，如果父进程没有正确地处理子进程地返回信息，子进程都将停留在僵尸态，并占据着内核资源。<br>  下面这对函数在父进程中调用，以等待子进程的结束，并获取子进程的返回信息，从而避免了僵尸进程的产生，或使处于僵尸态的子进程立即结束。<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *status)</span>;<br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *status, <span class="hljs-type">int</span> options)</span>;<br></code></pre></td></tr></table></figure></p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ul><li>管道实现进程内部的通信，也是父进程与子进程间的通信手段<br>管道能在父、子进程之间传递数据，利用的是fork调用之后两个管道文件描述符（fd[0] fd[1]）都保持打开。一对这样的文件描述符，只能保证父、子进程间一个方向的数据传输，父&#x2F;子进程必须有一个关闭fd[0],另一个关闭fd[1]。如图：</li></ul><p>显然，父&#x2F;子进程之间想要双向传递数据，必须使用两个管道。socket编程接口提供了一个创建全双工管道的系统调用：socketpair 。</p><ul><li>管道只能用于<strong>有关联</strong>的两个进程（父 子）的通信。接下来我们聊聊3种System V IPC能用于<strong>无关联</strong>的多进程之间的通信。因为他们都使用一个全局唯一的键值来标识一条信道。</li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><h5 id="信号量原语"><a href="#信号量原语" class="headerlink" title="- 信号量原语"></a>- 信号量原语</h5><p> 当多个进程同时访问系统上的某个资源的时候，比如同时写一个数据库的某条记录，或者同时修改某个文件，就需要考虑进程的同步问题，以确保任一时刻只有一个进程可以拥有对资源的独占式访问。<br> 通常，程序对共享资源的访问的代码只是很短的一段，但这段代码引发了进程之间的竞态条件。我们称这段代码为<strong>关键代码段&#x2F;临界区</strong>。对进程同步，也就是确保任一时刻只有一个进程能进入关键代码段。<br> 要编写具有通用目的的代码，以确保关键代码段的独占式访问是非常困难的。<br> Dijkstra提出的信号量概念是并发编程领域迈出的重要一步。</p><ul><li>信号量<br>  信号量是一种特殊的变量，它只能取自然数值并且只支持两种操纵：等待（wait）和信号（signal）,不过在Linux&#x2F;UNIX中，”等待”和”信号”都已经具有特殊的含义，所以对信号量的这两种操作更常用的称呼是P和V操作。<br>  <strong>p (传递 好像进入临界区)  v (释放 好像退出临界区)</strong><br>  假设有信号量SV,则对它的P、V操作，其语义为：<ul><li>P(SV)：如果SV的值＞0，就将它减一；若SV&#x3D;0，则挂起进程的执行</li><li>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，则SV+1<br>信号量的取值可以是任何自然数，但最常用的、最简单的信号量是二进制信号量，它只能取0或1这两个值。我们仅讨论二进制信号量。<br>使用二进制信号量同步两个进程，以确保关键代码段的独占式访问。<br>🌰 举个例子：<br><img src="/images/25.jpg"><br>当关键代码段可用时，二进制信号量SV的值为1，进程A、B都有机会进入关键代码段。如果此时A执行了P(SV)操作将SV-1，则进程B若再执行P(SV)操作就会被挂起。直到A离开关键代码段，并执行V(SV)操作将SV+1，关键代码段才重新变得可用。如果此时B因为等待SV而处于挂起状态，则它将被唤醒，并进入关键代码段。同样，这时A如果再执行P(SV)操作，则也只能被操作系统挂起以等待B退出关键代码段。</li></ul></li><li>PS:<br> 使用一个普通变量来模拟二进制信号量是不行的。因为所有高级语言都没有一个原子操作可以同时完成如下的两步操作：1. 检测变量是否为false&#x2F;true  2. 如果是，则再将它设置为false&#x2F;true</li><li>Linux信号量的API都定义在sysys&#x2F;sem.h头文件中，主要包含3个系统调用：semget, semop, semctl。它们都被设计为操作一组信号量，即信号量集，而不是单个信号量。（暂不探讨）</li></ul><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><ul><li>共享内存是<strong>最高效</strong>的IPC机制，因为它不涉及进程之间的任何数据传输。这种高效率带来的问题是，我们必须用其他辅助手段来同步进程对共享内存的访问，否则会产生竞态条件。因此，共享内存通常和其他进程间通信方式一起使用。</li></ul><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul><li>消息队列是在两个进程之间传递二进制块数据的一种简单有效的方式。每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据，而不一定像管道&#x2F;命名管道那样必须以FIFO顺序来接收数据。</li></ul><h4 id="IPC命令"><a href="#IPC命令" class="headerlink" title="IPC命令"></a>IPC命令</h4><p>上述3种System V IPC进程间通信方式都使用一个全局唯一地键值（key）来描述一个共享资源。<br>当程序调用semget、shmget、msgget等时，就创建了这些共享资源的一个实例。Linux提供了ipcs命令，以观察当前系统上拥有了拥有哪些共享资源实例。如下图：<br><img src="/images/27.jpg"><br>输出结果分段显示了系统拥有的共享内存、信号量和消息队列资源。目前系统尚未使用任何共享内存和消息队列，却分配了一组键值为0（IPC_PRIVATE）的信号量。这些信号量的所有者是apache,因为它们是由httpd服务器程序创建的。<br>此外，我们可以使用ipcrm命令来删除这些资源实例。</p><h4 id="在进程间传递文件描述符"><a href="#在进程间传递文件描述符" class="headerlink" title="在进程间传递文件描述符"></a>在进程间传递文件描述符</h4><ul><li>这一块我没懂想说明什么，暂不讨论。</li></ul><h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><ul><li>创建与结束线程</li><li>读取和设置线程属性</li><li>POSIX线程同步方式：POSIX信号量、互斥锁、条件变量</li></ul><p>本文最后，我们也会讨论下Linux环境下，库函数、进程、信号与多线程程序之间的相互影响。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>Linux高性能服务器编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>服务器编程</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程读书笔记（一）</title>
    <link href="/2025/11/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2025/11/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="笔记目录-（TCP-IP协议详解）"><a href="#笔记目录-（TCP-IP协议详解）" class="headerlink" title="笔记目录 （TCP&#x2F;IP协议详解）"></a>笔记目录 （TCP&#x2F;IP协议详解）</h2><p>引言： 我尽量把书中看到的知识点和最近在网络上看到的一些技术文章做一些记录，一是对这部分知识更全面、体系化的思考，二是记录一些不错的知识点，分享给大家，建议大家还是自己亲自读一读。</p><ol><li>TCP&#x2F;IP协议族</li><li>IP协议详解</li><li>TCP协议详解</li></ol><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP&#x2F;IP协议族"></a>TCP&#x2F;IP协议族</h2><h2 id="IP协议详解"><a href="#IP协议详解" class="headerlink" title="IP协议详解"></a>IP协议详解</h2><h2 id="TCP协议详解"><a href="#TCP协议详解" class="headerlink" title="TCP协议详解"></a>TCP协议详解</h2><p>TCP协议理解概述</p><ol><li>TCP头部信息（用于指定源端口、目标端口、管理TCP链接、控制两个方向的数据流）</li><li>TCP状态转移过程（TCP连接的任意一端都是一个状态机）</li><li>Tcp数据流以及对数据流的控制</li></ol><p>TCP服务特点</p><ol><li>通信双方都必须为该连接分配必要的内核资源，以便管理连接的状态和连接上的数据流传输</li><li>一对一连接，因此比起UDP，TCP还有一个特点是不适用基于广播&#x2F;多播（目标是多个主机地址）的应用程序（这个点，我在被常规八股中，还从来没见到有谁总结过）</li><li>思考 数据包 or 字节流 到底在说什么？<br>回答：当接收端收到一个或多个TCP报文段后，TCP模块将他们携带的应用程序数据按照TCP报文段的顺序依次放入TCP接收缓冲区中并通知应用程序读取数据；应用程序这边，可以一次读完，也可分次去读，取决于用户指定的应用程序读缓冲区的大小。应用程序的读次数和TCP模块接收到的TCP报文段个数无关。</li></ol><p>现在我来回答<strong>字节流</strong>的概念：发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，这就是字节流的概念。应用程序对数据的发送和接收无边界限制。UDP则不然。发送端应用程序每执行一次写操作，UDP模块就会封装一个UDP报文段并发送。接收端必须及时接收（执行读操作，通过recvfrom系统调用），不然，就丢包。并且，如果用户指定的应用程序读缓冲区大小不够，UDP报文也会被截断。<br>来个栩栩如生的好图：<br><img src="/images/22.jpg"><br>TCP 的可靠：确认应答机制 + 开了个定时器</p><p>以及今天看了Julia Evans这篇文章《Why do we use the Linux kernel’s TCP stack?》<br>如果你想用自实现的用户态TCP堆栈，是在追求什么？<br>A： </p><ol><li>极致性能：<br>避免内核上下文切换、系统调用和内存拷贝。<br>可完全控制网络处理逻辑，减少锁竞争和共享状态（符合“端到端原则”）。</li><li>灵活性与快速迭代：<br>内核更新慢，难以支持新协议特性（如 TCP Fast Open）。Google 就因无法强制 Android 厂商升级内核，而更倾向用户态实现。</li></ol><p>目前流行不起来的原因何在？<br>A:</p><ol><li>内核 TCP 栈是“默认且合理”的选择，因其成熟、通用、省心。</li><li>用户态网络栈适用于极端性能或特殊需求场景（如追求极致性能的交易、超大规模负载均衡）。</li><li>势是“将网络处理推向用户态”，以减少内核干预，提升可扩展性与灵活性。</li><li>社区正在探索通用化用户态网络方案（如 LKL、libuinet），但尚未成熟。</li></ol><p>📌 补充背景<br>Cloudflare 工程师 Marek Majkowski 在其文章《Why we use the Linux kernel’s TCP stack》直接回应了 Julia Evans 博客的问题，强调了工程实践中“稳健性”和“长期可维护性”往往比理论峰值性能更重要。Cloudflare 的立场代表了许多大型生产系统的务实选择。</p><p>正如 Marek 所说：</p><p>“We are not in the business of writing TCP stacks. We are in the business of securing and accelerating the web.”</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
      <category>Linux高性能服务器编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>服务器编程</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一天Go (日记纪念版)</title>
    <link href="/2024/04/27/%E7%AC%AC%E4%B8%80%E5%A4%A9Go/"/>
    <url>/2024/04/27/%E7%AC%AC%E4%B8%80%E5%A4%A9Go/</url>
    
    <content type="html"><![CDATA[<p>记录第一天学习go, 附上第一句话：“Hello World!”<br><img src="/images/17.png"></p><p>我被Gopher可爱到了，地鼠啊哈哈哈，怎么会有这么戳我蠢萌点的吉祥物啊，越看越想笑。开GO!</p>]]></content>
    
    
    <categories>
      
      <category>GO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用Go实战IM即时消息系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务架构</title>
    <link href="/2024/04/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/04/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p> 单体架构： 将业务的所有功能集中在一个项目里开发，打成一个包部署。（缺点：耦合度高）适合小型项目，例如：学生管理系统</p><h3 id="分布式架构：-根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。（特点：松耦合，扩展性好）"><a href="#分布式架构：-根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。（特点：松耦合，扩展性好）" class="headerlink" title="分布式架构： 根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。（特点：松耦合，扩展性好）"></a>分布式架构： 根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。（特点：松耦合，扩展性好）</h3><p>分布式架构要考虑的问题：</p><ol><li>服务拆分粒度如何</li><li>服务集群地址如何维护</li><li>服务之间如何实现远程调用</li><li>服务健康状态如何感知</li></ol><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p> 微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征：</p><ol><li>单一职责：微服务拆分粒度更小，每个服务都对应唯一的业务功能，做到单一职责，避免重复业务开发</li><li>面向服务：微服务对外暴露业务接口</li><li>自治：团队独立、技术独立、数据独立、部署独立</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ol>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务技术栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分析布隆过滤器解决缓存穿透问题</title>
    <link href="/2024/04/18/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2024/04/18/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>缓存穿透：由用户大量向缓存和数据库不存在数据发送恶意请求，从而绕过缓存，直接访问数据库，最终导致数据库崩溃。</p><p>如何在海量元素中（例如 10 亿无序、不定长、不重复）快速判断一个元素是否存在。</p><p>这个问题涉及两个关键点：海量数据、快速判断。</p><p>如果我们直接把这些元素的值放到基本的数据结构Set里面，会十分占用空间。</p><p>所以，我们存储这几十亿个元素，不能直接存值，我们应该找到一种最简单的最节省空间的数据结构，用来标记这个元素有没有出现。这个东西我们就把它叫做<mark>位图</mark>，是一个有序的数组，只有两个值，0 和 1。0 代表不存在，1 代表存在。</p><p>要让这个数组标记这些元素是否存在，必须有一个映射方法。</p><p>这个映射方法需要符合一下基本要求：</p><ol><li>因为值长度是不固定的，所以希望不同长度的输入，可以得到固定长度的输出。</li><li>转换成下标的时候，希望在这个有序数组里面分布均匀，不然元素全部挤到一起，无法判断哪个元素存了，哪个没存。</li></ol><p>结合上面两个要求，使用分布性性能优良的哈希函数加上相应的取模方法，可以得到相应下标。<br><img src="/images/10.png"></p><p>具体如上图，数据经过哈希计算并取模得到相应的数组下标，并把该下标值置1，表示存在。<br>然后到时判断数据是否存在时，只需要把数据用相应的函数计算出下标，再查看对应数据元素是否为1，1则存在，0则不存在。</p><p><em><strong>哈希碰撞 :</strong></em> hash碰撞指的是，两个不同的值（比如张三、李四的学号）经过hash计算后，得到的<strong>hash值相同</strong>，后来的李四要放到原来的张三的位置，但是数组的位置已经被张三占了，<strong>导致冲突</strong>。<br>hash碰撞的解决方式是开放寻址法和拉链法<br>hash存数据如下图：<br><img src="/source/images/11.png"></p><p>由于会出现哈希碰撞，此时YaoMing和Kobe Bryant计算出了相同的下标。所以此时使用该方法判断数据是否存在就会出现误差，比如假如Kobe Bryant实际上是不存在，但是YaoMing数据已经把下标6的元素置1了，然后Kobe Bryant经过运算得到下标为6，此时他去查看6元素是否为1，因为YaoMing已经把他置1了，所以会判断Kobe Bryant是存在，但是实际上它是不存在的。</p><p>因为哈希冲突会导致判断出错，所以要尽量减少哈希冲突的概率。方法有：</p><ol><li>增大位图数组的容量，因为我们的函数是分布均匀的，所以，位图容量越大，在同一个位置发生哈希碰撞的概率就越小，但是位图数组容量增大意味着会增大内存的消耗，所以不能不讲道理地扩大位图容量，应该是在错误率和位图容量中平衡取值。</li><li>如果数据经过一次哈希计算，得到的相同下标的概率比较高，如果计算多次呢？ 原本只用一个哈希函数，现在对于每一个要存储的元素都用多个哈希函数计算，这样每次计算出来的下标都相同的概率就小得多了。但是 我们也不讲道理地使用很多次的哈希计算函数，因为很多次的哈希计算会消耗掉cpu的性能，和延长判断速度。<br>所以总的来说，我们既要节省空间，又要很高的计算效率，就必须<mark>在位图容量和函数个数之间找到一个最佳的平衡</mark>。</li></ol><p>对于如何取得平衡，这个事情早就有人研究过了，在 1970 年的时候，有一个叫做布隆的前辈对于判断海量元素中元素是否存在的问题进行了研究，也就是到底需要多大的位图容量和多少个哈希函数，它发表了一篇论文，提出的这个容器就叫做布隆过滤器。</p><p>但是无论如果也不可能达到100%正确率，除非使用绝对均匀的下标算法和绝对大于元素个数且随时扩容的位数组。</p><p>所以，这个是布隆过滤器的一个很重要的特性，因为哈希碰撞不可避免，所以它会存在一定的误判率。这种把本来不存在布隆过滤器中的元素误判为存在的情况，我们把它叫做假阳性（False Positive Probability，FPP）。</p><h2 id="布隆过滤器的特点："><a href="#布隆过滤器的特点：" class="headerlink" title="布隆过滤器的特点："></a>布隆过滤器的特点：</h2><p> <strong>容器角度</strong>：</p><ol><li><p>如果布隆过滤器判断结果为元素存在，那么该元素实际上元素不一定会存在，由于哈希碰撞，所以会存在一定误判率，上面已经说明了。</p></li><li><p>如果布隆过滤器判断结果为元素不存在，那么他就一定不存在，因为无论哈希碰撞啥的，只要该元素计算出下标值对应数组元素值为0，那么该元素就必定不存在.</p></li></ol><p>布隆过滤器是不支持删除元素的，因为如果位图的某个位置被多个元素占用着，那么如果删除其中一个元素是否能将该位置0,能置0的话会影响到其他元素，不置0就等于没删除。</p><p> <strong>元素角度</strong>：</p><ol><li><p>如果元素实际存在，布隆过滤器可能判断存在，也可能判断为不存在，存在误判。<br>如果元素实际不存在，布隆过滤器一定判断不存在。</p></li><li><p>利用第二个特性，我们就能解决持续从数据库查询不存在的值的问题，把要查询的值先过布隆过滤器，判断是否存在，存在就走redis缓存，不存在就直接返回，并且配合缓存空值，可以有效解决缓存穿透问题，虽然存在一定误差，但是在业务范围内允许接受。<br><img src="/images/12.png"></p></li></ol><h2 id="布隆过滤器实战"><a href="#布隆过滤器实战" class="headerlink" title="布隆过滤器实战"></a>布隆过滤器实战</h2><p>我们可以引入最新的坐标，然后就可以使用了<br>所用： Guava：Java开发者的全方位工具库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;<br>    &lt;artifactId&gt;guava&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">31.1</span>-jre&lt;/version&gt;<br>&lt;/dependency&gt;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.bloomfilterdemo;<br><br><span class="hljs-keyword">import</span> com.google.common.base.Charsets;<br><span class="hljs-keyword">import</span> com.google.common.hash.BloomFilter;<br><span class="hljs-keyword">import</span> com.google.common.hash.Funnels;<br><br><span class="hljs-keyword">import</span> java.text.NumberFormat;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@decription</span></span><br><span class="hljs-comment"> * 测试布隆过滤器的正确判断和误判</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 往布隆过滤器里面存放100万个元素</span><br><span class="hljs-comment"> * 测试100个存在的元素和9900个不存在的元素</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomFilterDemo</span> &#123;<br>    <span class="hljs-comment">//元素个数100万个</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">insertions</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建一个布隆过滤器，第二个值是元素的个数</span><br>        <span class="hljs-comment">//初始化一个存储String数据的布隆过滤器，初始化大小为100w</span><br>        <span class="hljs-comment">//默认误判率是0.03</span><br>        BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), insertions, <span class="hljs-number">0.03D</span>);<br><br>        <span class="hljs-comment">//用于存放所有实际存在的key,判断key是否存在，可快速判断key存在&lt;</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(insertions);<br><br>        <span class="hljs-comment">//用于存放所有实际存在的key,可以取出使用，这个可供使用下标取出</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(insertions);<br><br>        <span class="hljs-comment">//插入数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; insertions; i++) &#123;<br>            <span class="hljs-comment">//UUID 是 通用唯一识别码(Universally Unique Identifier)，主要是让分布式系统中的所有元素，都有唯一的辨识信息</span><br>            <span class="hljs-comment">//随机生成UUID的标识符是UUID类中的方法</span><br>            <span class="hljs-comment">//而UUID.randomUUID().toString()是javaJDK提供的一个自动生成主键的方法</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>            bloomFilter.put(uuid);<br>            set.add(uuid);<br>            list.add(uuid);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">wrong</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-comment">//可以被100整除的时候，取一个存在的数。否则随机生成一个UUID</span><br>            <span class="hljs-comment">//0-10000之间，可以被100整除的数有100个（100的倍数)</span><br>            <span class="hljs-comment">//这里就是实现100个存在key,9900个不存在key</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> i % <span class="hljs-number">100</span> == <span class="hljs-number">0</span> ? list.get(i / <span class="hljs-number">100</span>) : UUID.randomUUID().toString();<br><br>            <span class="hljs-comment">// bloomFilter.mightContain(data)   布隆过滤器提供的方法用于判断数据是否命中</span><br>            <span class="hljs-keyword">if</span> (bloomFilter.mightContain(data)) &#123;<br>                <span class="hljs-keyword">if</span> (set.contains(data)) &#123;<br>                    <span class="hljs-comment">//判断存在，实际存在的时候，命中</span><br>                    right++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//判断存在却不存在的时候，错误++</span><br>                wrong++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//计算命中率和误判率</span><br>        <span class="hljs-type">NumberFormat</span> <span class="hljs-variable">percentFormat</span> <span class="hljs-operator">=</span> NumberFormat.getPercentInstance();<br>        percentFormat.setMaximumFractionDigits(<span class="hljs-number">2</span>); <span class="hljs-comment">//最大小数位数</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">percent</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) wrong / <span class="hljs-number">9900</span>;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">bingo</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (<span class="hljs-number">9900</span> - wrong) / <span class="hljs-number">9900</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;在100W个元素中，判断100个实际存在的元素，布隆过滤器认为存在的： &quot;</span> + right);<br>        System.out.println(<span class="hljs-string">&quot;在100W个元素中，判断9900个实际不存在的元素，布隆过滤器误认为存在的：&quot;</span> + wrong + <span class="hljs-string">&quot;&quot;</span> +<br>                <span class="hljs-string">&quot;,命中率: &quot;</span> + percentFormat.format(bingo) + <span class="hljs-string">&quot;,误判率：&quot;</span> + percentFormat.format(percent));<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">numOfBits</span> <span class="hljs-operator">=</span> optimalNumOfBits(insertions, <span class="hljs-number">0.03D</span>);<br>        System.out.println(<span class="hljs-string">&quot;100w个元素，误判率为3%的情况下，位图容量为：&quot;</span> + (numOfBits / <span class="hljs-number">8.0</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;100w个元素，误判率为3%的情况下，哈希函数个数为：&quot;</span> + (optimalNumOfHashFunctions(insertions, numOfBits)) + <span class="hljs-string">&quot;个&quot;</span>);<br><br>    &#125;<br><br>    <br>        <span class="hljs-comment">//下面两个方法是BloomFilter的方法，只是在里面是包权限，这里就直接复制出来用了。</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 计算出哈希函数个数</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> expectedInsertions  期望元素个数</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> numOfBits  位图容量</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">optimalNumOfHashFunctions</span> <span class="hljs-params">( <span class="hljs-type">long</span> expectedInsertions, <span class="hljs-type">long</span> numOfBits)</span>&#123;<br>            <span class="hljs-keyword">return</span> Math.max(<span class="hljs-number">1</span>, (<span class="hljs-type">int</span>) Math.round((<span class="hljs-type">double</span>) numOfBits / (<span class="hljs-type">double</span>) expectedInsertions * Math.log(<span class="hljs-number">2.0D</span>)));<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 计算出位图容量</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> expectedInsertions 期望元素个数</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> fpp  误判率</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">optimalNumOfBits</span> <span class="hljs-params">( <span class="hljs-type">long</span> expectedInsertions, <span class="hljs-type">double</span> fpp)</span>&#123;<br>            <span class="hljs-keyword">if</span> (fpp == <span class="hljs-number">0.0D</span>) &#123;<br>                fpp = <span class="hljs-number">4.9E-324D</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>) ((<span class="hljs-type">double</span>) (-expectedInsertions) * Math.log(fpp) / (Math.log(<span class="hljs-number">2.0D</span>) * Math.log(<span class="hljs-number">2.0D</span>)));<br>        &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/13.png"><br>连续多次的执行结果，误判率都在3%左右，因为默认的误判率为3%。并且使用0.87MB的位图容量加5个哈希函数就可以达到100w数据的快速判断是否存在。只是存在3%的误判率。<br>可以指定误判率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//最后一个参数就是误判率，这里设置的是0.1  10%。</span><br>BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8),insertions,<span class="hljs-number">0.1D</span>);<br></code></pre></td></tr></table></figure><p>布隆过滤器会根据元素个数和误判率来自动跳转哈希函数个数和位数组的容量。</p><h2 id="布隆过滤器其他应用场景："><a href="#布隆过滤器其他应用场景：" class="headerlink" title="布隆过滤器其他应用场景："></a>布隆过滤器其他应用场景：</h2><ol><li>海量数据过滤</li><li>数据url爬虫，爬海量url</li><li>还有我们的邮箱服务器，发送垃圾邮件的账号我们把它们叫做 spamer，在这么多的邮箱账号里面，怎么判断一个账号是不是 spamer 等一些场景</li></ol><p>布隆过滤器的优点是海量数据、快速判断，缺点是存在一定的误判率。</p><p>存储10亿个UUID，使用的内存对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Obj1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">insertions</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000000</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString().getBytes().length*insertions;<br>        System.out.println(<span class="hljs-string">&quot;用set存储10亿个UUID，消耗内存：&quot;</span>+(g/<span class="hljs-number">1024.0</span>/<span class="hljs-number">1024.0</span>/<span class="hljs-number">1024.0</span>) + <span class="hljs-string">&quot;GB&quot;</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">numOfBits</span> <span class="hljs-operator">=</span> BloomFilterDemo.optimalNumOfBits(insertions,<span class="hljs-number">0.03D</span>);<br>        System.out.println(<span class="hljs-string">&quot;10亿个元素，误判率为3%的情况下，位图容量为：&quot;</span>+(numOfBits/<span class="hljs-number">8.0</span>/<span class="hljs-number">1024</span>/<span class="hljs-number">1024</span>/<span class="hljs-number">1024</span>)+<span class="hljs-string">&quot;GB&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;10亿个元素，误判率为3%的情况下，哈希函数个数为：&quot;</span>+(BloomFilterDemo.optimalNumOfHashFunctions(insertions,numOfBits))+<span class="hljs-string">&quot;个&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/14.png"><br>用set存储，需要33.527GB内存，<strong>用布隆过滤器只需0.849GB+5个哈希函数计算+3%的误判率，差了39.5倍</strong>，但是要牺牲一定准确性。并且布隆过滤器的位图增长只会与元素个数有关，与元素的大小没有关系，而用set存储的话，还与元素的大小有关，假如每个元素达到1kb大小，那结果不堪设想…</p>]]></content>
    
    
    <categories>
      
      <category>缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>海量数据、快速判断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Redis为何那么快（二）</title>
    <link href="/2024/04/15/%E6%B5%85%E8%B0%88Redis%E4%B8%BA%E4%BD%95%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/04/15/%E6%B5%85%E8%B0%88Redis%E4%B8%BA%E4%BD%95%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="高效的内存数据结构"><a href="#高效的内存数据结构" class="headerlink" title="高效的内存数据结构"></a>高效的内存数据结构</h1><p><img src="/images/7.png"></p><h3 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h3><p>动态字符串是一种能够动态扩展长度的字符串实现方式。SDS是Redis中的一种简单动态字符串结构，它是一种动态大小的字节数组，用于存储和操作字符串数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * redis中保存字符串对象的结构</span><br><span class="hljs-comment"> */</span><br>struct sdshdr &#123;<br>    <span class="hljs-comment">//用于记录buf数组中使用的字节的数目，和SDS存储的字符串的长度相等 </span><br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-comment">//用于记录buf数组中没有使用的字节的数目 </span><br>    <span class="hljs-type">int</span> free;<br>    <span class="hljs-comment">//字节数组，用于储存字符串</span><br>    <span class="hljs-type">char</span> buf[]; <span class="hljs-comment">//buf的大小等于len+free+1，其中多余的1个字节是用来存储’\0’的</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>Redis的SDS的数据结构使用一个len字段记录当前字符串的长度，使用free表示空闲的长度。想要获取长度只需要获取len字段即可。<br><img src="/images/8.png"><br>而对比C语言，传统字符串是使用长度为N+1的字符数组来表示长度为 的字符串，并且字符串数组的最后一个元素总是空字符’\0’。<br>SDS相对于C语言字符串有如下优点：</p><ol><li><strong>二进制安全</strong> :SDS可以存储任意二进制数据，而不仅仅是文本字符串(包括图片、视频、音频等在内的各种二进制数据)，而不会受到空字符或者特殊字符的限制，具有更广泛的适用性。</li><li><strong>动态扩展</strong> : SDS可以根据存储的字符串长度动态调整，根据实际需要动态分配和释放内存空间。</li><li><strong>O(1)时间复杂度</strong> </li><li><strong>缓冲区溢出保护</strong> : SDS在存储字符串时，会自动添加一个空字符串（’\O’）作为字符串的结束标志，保证字符串的安全性和稳定性。</li><li><strong>惰性空间释放</strong> : 当SDS缩短字符串时，并不会立即释放多余空间，多余空间会保存下来，以备后续再利用。这种惰性空间释放策略可以减少内存分配和释放的开销，提高内存利用率。</li></ol><h3 id="双端链表"><a href="#双端链表" class="headerlink" title="双端链表"></a>双端链表</h3><p>Redis中的双端链表是一种经过优化的数据结构，用于存储有序数据集合。它具有双向连接的特性，每个节点都包含前一个节点和后一个节点的指针。<br><img src="/images/9.png"><br>在Redis中，双端链表节点的定义通常如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span>  <span class="hljs-comment">// 指向前一个节点的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 指向后一个节点的指针</span><br>    <span class="hljs-type">void</span> *value;            <span class="hljs-comment">// 存储的数据元素</span><br>&#125; listNode;<br></code></pre></td></tr></table></figure><p>对于链表中描述链表整体属性的元数据，它的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br>    listNode *head;  <span class="hljs-comment">// 头节点指针</span><br>    listNode *tail;  <span class="hljs-comment">// 尾节点指针</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;  <span class="hljs-comment">// 链表长度</span><br>    <span class="hljs-comment">// 其他字段...</span><br>&#125; <span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure><ol><li><strong>头结点</strong>（head node): 头结点是双端链表中的第一个节点，也是链表的入口。通常用于存储链表的起始位置信息，以便快速定位链表的起始位置。在双端链表中，头结点的特点是没有前一个节点，即头结点的 prev 为 NULL。头结点通常用于存储链表的头部元数据或者哨兵节点。</li><li><strong>尾结点</strong> (tail node): 尾结点是双端链表中的第一个节点，也是链表的结束位置。通常用于存储链表的结束位置信息，以便快速定位链表的结束位置。在双端链表中，尾结点的特点是没有最后一个节点，即尾结点的 next 为 NULL。尾结点通常用于存储链表的尾部元数据或者哨兵节点。</li></ol><p>通过头节点和尾节点，可以方便地对双端链表进行头部插入、尾部插入、头部删除、尾部删除等操作，从而实现了对双端链表的高效操作。<br>除了上述头尾节点以外，链表的元数据中还有len参数，这个参数用于记录链表的当前长度。每当链表中添加或删除节点时，Redis会相应地更新len字段的值，以反映链表的当前长度。这个参数与SDS里类似，获取链表长度时不用再遍历整个链表，直接拿到len值就可以了，这个时间复杂度是 O(1)。</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>本文探讨Redis之所以快速处理大规模数据的原因</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《论持久战》顶级战略思维</title>
    <link href="/2024/04/15/%E8%8A%B1%E4%B8%80%E5%B9%B4%E8%AF%BB%E6%AF%9B%E9%80%89/"/>
    <url>/2024/04/15/%E8%8A%B1%E4%B8%80%E5%B9%B4%E8%AF%BB%E6%AF%9B%E9%80%89/</url>
    
    <content type="html"><![CDATA[<h3 id="写作背景"><a href="#写作背景" class="headerlink" title="写作背景"></a>写作背景</h3><p>《论持久战》写于1938年，日军全面侵华刚开始，当时亡国论和速胜论等多方声音盘旋，这篇文章主要是给战争态势做一个分析与总结，并且牵引革命前行的一个演讲。</p><h3 id="二维辩证法分析矩阵"><a href="#二维辩证法分析矩阵" class="headerlink" title="二维辩证法分析矩阵"></a>二维辩证法分析矩阵</h3><pre><code class="hljs">中国内部 中国外部日本内部 日本外部</code></pre><p><img src="/images/6.png"><br>在这篇文章中，教员分析到 战争的胜利取决于三个方面：</p><ol><li>中国抗日统一战线的完成</li><li>国际抗日统一战线的完成</li><li>日本国内人民和日本殖民地人民的革命运动的兴起<br>就中国人民的立场来说，三个条件中，中国人民的大联合是主要的。</li></ol><h4 id="外因的存在加速了内部矛盾的转化"><a href="#外因的存在加速了内部矛盾的转化" class="headerlink" title="外因的存在加速了内部矛盾的转化"></a>外因的存在加速了内部矛盾的转化</h4><p>摘：<em><strong>历史积累下来的腐败现象，虽然很严重地阻碍着人民抗战力量增长的速度，减少了战争的胜利，招致了战争的损失，但是中国、日本和世界的大局，不容许中国人民不进步。由于阻碍进步的因素即腐败现象之存在，这种进步是缓慢的。进步和进步缓慢是目前时局的两个特点，后一个特点和战争的迫切要求很不相称。然而我们是在革命战争中，革命战争是一种抗毒素，它不但将排除敌人的毒焰、也将清除自己的污浊。</strong></em></p><p>教员分析了中国当时的外部环境和日本当时的外部环境。<br>同时也涉及了论持久战中的道义问题。</p><p>摘：<em><strong>日本虽能得到国际法西斯国家的援助，但同时，却又不能不遇到一个超过其国际援助力量的国际反对力量。这后一种力量将逐渐地增长，终究不但将前者的援助力量抵消，并将施其压力于日本自身。</strong></em></p><h4 id="目标定力：如何看懂-妥协？迂回"><a href="#目标定力：如何看懂-妥协？迂回" class="headerlink" title="目标定力：如何看懂 妥协？迂回"></a>目标定力：<em><strong>如何看懂 妥协？迂回</strong></em></h4><p>很简单，妥协是目标层面的事情，迂回是执行层面的事情。<br>我党战争经常讲究迂回策略，十六字箴言：<strong>敌进我退，敌驻我扰，敌疲我打，敌退我追。</strong></p><h4 id="长期主义"><a href="#长期主义" class="headerlink" title="长期主义"></a>长期主义</h4><p>从1931年九一八事变开始到1945年8月15日，14年，全国人民都在做一件事：把日本鬼子赶出中国。<br>1938年初，教员在长期主义战略思维下，认为抗日战争分为三阶段：</p><ol><li>第一阶段：敌之战略进攻，我之战略防御</li><li>第二阶段（<strong>战略相持阶段</strong>）：敌之战略保守，我之准备反攻</li><li>第三阶段：我之战略进攻，敌之战略退却</li></ol><p>战略相持阶段，是最考验、最痛苦的阶段。教员分析：<em><strong>大体上我们要准备付给较长的时间，要熬得过这段艰难的路程。这将是中国很痛苦的时期，经济困难和汉奸捣乱将是两个很大的问题。敌人将大肆其破坏中国统一战线的活动，一切敌之占领地的汉奸组织将合流组成所谓“统一政府”。我们内部，因大城市的丧失和战争困难，动摇分子将大倡其妥协轮，悲观情绪将严重增长。此时我们的任务，在于动员全国民众，齐心一致，绝不动摇地坚持战争，把统一战线扩大和巩固起来，排除一切悲观主义和妥协论，提倡艰苦斗争，实行新的战时政策，熬过这一艰难路程。</strong></em></p><p>排除一切悲观主义，熬过去，拨云见日，看到更大的风景。</p><p>摘：这个第二阶段是整个战争的过渡阶段，也将是最困难的时期，然而它是转变的枢纽。<em><strong>中国将变为独立国，还是沦为殖民地，不决定第一阶段大城市之是否丧失，而决定于第二阶段全民族努力的程度。</strong></em> 如能坚持抗战，坚持统一战线和坚持持久战，中国将在此阶段中获得转弱为强的力量。中国抗战的三幕戏，这是第二幕。由于全体演员的努力，最精彩地结幕便能很好地演出来。</p><h4 id="动态视角"><a href="#动态视角" class="headerlink" title="动态视角"></a>动态视角</h4><p>一般人看援助力量是多是少，而教员是看 <strong>援助力量的变化速度</strong></p><ol><li>中国抗日战争的正义性和进步性</li><li>中国之大国，有打持久战的能力</li></ol><p>摘：这就是战争中的经验，军队的进步，政治的进步，人民的动员，文化的新方向的发展，游击战的出现，国际援助的增长等等。在第一阶段，向下的东西是旧的量和质，主要地表现在量上。向上的东西是新的量和质，主要地表现在质上。这第二种变化，就给了我们以能够持久和最后胜利的根据。</p><p>要减少 唯心主义 和 机械论</p><p>摘：<em><strong>所谓“唯武器论”，是战争问题中的机械论，是主观和片面看问题的意见。要看武器，更要看人力。武器是战争的重要因素，但不是决定因素，决定因素是人不是物。力量对比不单是军力与经济力的对比，而且是人力与人心的对比。军力和经济力是要人去掌握的。中国只要坚持抗战和统一战线，其军力和经济力是能够逐渐地加强的。</strong></em></p><p>摘：谁人不知，为争取时间和准备反攻而流血战斗，某些土地虽仍不能免于放弃，时间却争取了，给敌以歼灭和给敌以消耗的目的却达到了，自己的战斗经验却取得了，没有起来的人民却起来了，国际地位却增长了。这种血是白流的吗？一点也不是白流的。放弃土地是为了保存军力，也正是为了保存土地。</p><p>摘：<strong>资本家做生意是要有本钱的，全部破产之后，也算不得什么资本家。赌汉也要赌本，孤注一掷，不幸不中，就无从再赌。事务是往返曲折的，不是径情直遂的，战争也是一样，只有形式主义者想不通这个道理。</strong></p>]]></content>
    
    
    <categories>
      
      <category>毛选</category>
      
    </categories>
    
    
    <tags>
      
      <tag>详细读《论持久战》，关于辩证的矛盾分析、战略定力和长期主义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal（3）常见使用场景</title>
    <link href="/2024/04/14/ThreadLocal(3)/"/>
    <url>/2024/04/14/ThreadLocal(3)/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal-常见使用场景"><a href="#ThreadLocal-常见使用场景" class="headerlink" title="ThreadLocal 常见使用场景"></a>ThreadLocal 常见使用场景</h3><p>ThreadLocal作用在每一个线程内都需要独立的保存信息，这样就方便同一个线程的其他方法获取到该信息的场景，由于每一个线程获取到的信息可能都不一样，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal直接获取到，避免了传参，类似于全局变量的概念。比如像用户登录令牌解密后的信息传递、用户权限信息、从用户系统中获取到的用户名。<br><img src="/images/15.png"><br>如上图，线程创建了变量A,方法二是跟方法一在同一个线程内，变量A在该线程中共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用户微服务配置token解密信息传递例子</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">ThreadLocal</span><span class="hljs-params">(LoginUser)</span> threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>     <span class="hljs-type">LoginUser</span> <span class="hljs-variable">loginUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginUser</span>();<br>     loginUser.setId(id);<br>     loginUser.setName(name);<br>     loginUser.setMail(mail);<br>     loginUser.setHeadImg(headImg);<br>     threadLocal.set(loginUser);<br><br>后续想直接获取到，就threadLocal.getXXX即可<br></code></pre></td></tr></table></figure><h3 id="如何用ThreadLocal实现线程安全的问题"><a href="#如何用ThreadLocal实现线程安全的问题" class="headerlink" title="如何用ThreadLocal实现线程安全的问题"></a>如何用ThreadLocal实现线程安全的问题</h3><p>ThreadLocal适用于如下两种场景：</p><ol><li>每个线程需要自己单独的实例</li><li>实例需要在多个方法中共享，但不希望被多线程共享</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>存储用户Session</li></ol>]]></content>
    
    
    <categories>
      
      <category>多线程与并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈Threadlocal（3）常见使用场景</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Threadlocal（2）（源码分析）</title>
    <link href="/2024/04/14/ThreadLocal(2)/"/>
    <url>/2024/04/14/ThreadLocal(2)/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal原理（源码分析）"><a href="#ThreadLocal原理（源码分析）" class="headerlink" title="ThreadLocal原理（源码分析）"></a>ThreadLocal原理（源码分析）</h3><ol><li>ThreadLocal的set方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span>&#123;<br>    <span class="hljs-comment">//1.获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//2. 获取线程中的属性threadLocalMap,若threadLocalMap不为空，则直接更新要保存的变量值；</span><br>    <span class="hljs-comment">//否则创建threadLocalMap，并赋值。</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span>(map != <span class="hljs-literal">null</span>)&#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-comment">//初始化threadLocalMap 并赋值</span><br>      creatMap(t, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>从上面代码可知，ThreadLocal set赋值时首先会获取当前线程thread,并获取thread线程中的threadLocalMap属性。如果map属性不为空，则直接更新value值，如果为空，则实例化threadLocalMap，并赋值。</li></ol><p>接下来分析一下 threadLocalMap 和 createMap 的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br> <br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * The entries in this hash map extend WeakReference, using</span><br><span class="hljs-comment">       * its main ref field as the key (which is always a</span><br><span class="hljs-comment">       * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="hljs-comment">       * == null) mean that the key is no longer referenced, so the</span><br><span class="hljs-comment">       * entry can be expunged from table.  Such entries are referred to</span><br><span class="hljs-comment">       * as &quot;stale entries&quot; in the code that follows.</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>          <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>          Object value;<br> <br>          Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>              <span class="hljs-built_in">super</span>(k);<br>              value = v;<br>          &#125;<br>      &#125;<br> <br>      <br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看出 ThreadLocalMap是 ThreadLocal的静态类，它的构成主要用Entry来保存数据，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个是threadlocal 的内部方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>        t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>    &#125;<br> <br> <br>    <span class="hljs-comment">//ThreadLocalMap 构造方法</span><br>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>            table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>            table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>            size = <span class="hljs-number">1</span>;<br>            setThreshold(INITIAL_CAPACITY);<br>        &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>ThreadLocal的get方法： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-comment">//1. 获取当前线程</span><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>   <span class="hljs-comment">//2. 获取当前线程的ThreadLocalMap</span><br>   <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>   <span class="hljs-comment">//3. 如果map不为空</span><br>   <span class="hljs-keyword">if</span>(map != <span class="hljs-literal">null</span>)&#123;<br>       <span class="hljs-comment">//获取ThreadLocalMap中存储的值</span><br>       ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>       <span class="hljs-keyword">if</span>(e != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>           <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>           <span class="hljs-keyword">return</span> result;<br>       &#125;<br>   &#125; <br>   <span class="hljs-comment">//如果数据为null,则初始化，初始化结果，ThreadLocalMap中存放key值为ThreadLocal,值为null</span><br>   <span class="hljs-keyword">return</span> setInitialValue();<br><br>   <span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>       <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>       <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>           map.set(<span class="hljs-built_in">this</span>, value);<br>       <span class="hljs-keyword">else</span><br>           createMap(t, value);<br>       <span class="hljs-keyword">return</span> value;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>ThreadLocal的remove方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span>(m != <span class="hljs-literal">null</span>)&#123;<br>        m.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><strong>remove方法，直接将ThreadLocal对应的值从当前线程Thread中ThreadLocalMap中删除。为何删除，这涉及内存泄漏 （memory leak，指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。）的问题。</strong><br> 实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</li></ol><p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p><p>ThreadLocal其实是与线程绑定的一个变量，如此就会出现一个问题：如果没有将ThreadLocal内的变量删除（remove）或替换，它的生命周期将会与线程共存。通常线程池中对线程管理都是采用线程复用的方法，在线程池中线程很难结束甚至于永远不会结束，这将意味着线程持续的时间将不可预测，甚至与JVM的生命周期一致。举个例字，如果ThreadLocal中直接或间接包装了集合类或复杂对象，每次在同一个ThreadLocal中取出对象后，再对内容做操作，那么内部的集合类和复杂对象所占用的空间可能会开始持续膨胀。</p><h4 id="ThreadLocal与Thread，ThreadLocalMap之间的关系"><a href="#ThreadLocal与Thread，ThreadLocalMap之间的关系" class="headerlink" title="ThreadLocal与Thread，ThreadLocalMap之间的关系"></a>ThreadLocal与Thread，ThreadLocalMap之间的关系</h4><p><img src="/images/3.png"><br><img src="/images/4.png"><br>从这个图中我们可以非常直观的看出，ThreadLocalMap其实是Thread线程的一个属性值，而ThreadLocal是维护ThreadLocalMap这个属性值的一个工具类。<mark>Thread线程可以拥有多个ThreadLocal维护的自己线程独享的共享变量</mark>（这个共享变量只是针对自己线程里面共享）</p>]]></content>
    
    
    <categories>
      
      <category>多线程与并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈Threadlocal（2）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Threadlocal（1）</title>
    <link href="/2024/04/13/ThreadLocal/"/>
    <url>/2024/04/13/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h3><h4 id="ThreadLocal-线程变量-，意思是ThreadLocal中填充的变量属于当前线程。该变量对其他线而言是隔离的，该变量是当前线程的独有变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。"><a href="#ThreadLocal-线程变量-，意思是ThreadLocal中填充的变量属于当前线程。该变量对其他线而言是隔离的，该变量是当前线程的独有变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。" class="headerlink" title="ThreadLocal  (线程变量)，意思是ThreadLocal中填充的变量属于当前线程。该变量对其他线而言是隔离的，该变量是当前线程的独有变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。"></a>ThreadLocal <mark> (线程变量)</mark>，意思是ThreadLocal中填充的变量属于当前线程。该变量对其他线而言是隔离的，该变量是当前线程的独有变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</h4><p><em><strong>它的使用场合主要是为了解决多线程中因为数据并发产生不一致问题。</strong></em></p><p>ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：</p><ol><li>因为每个 Thread 内有自己的实例副本，且<mark>该副本只能由当前 Thread 使用</mark>。这是也是 ThreadLocal 命名的由来。</li><li>既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就<mark>不存在多线程间共享的问题</mark>。</li><li>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</li></ol><h4 id="总的来说，ThreadLocal-适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景"><a href="#总的来说，ThreadLocal-适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景" class="headerlink" title="总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景."></a>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景.</h4><p>下图是ThreadLocal在使用过程中的状态：<br><img src="/images/1.png"></p><h3 id="ThreadLocal与Synchronized的区别"><a href="#ThreadLocal与Synchronized的区别" class="headerlink" title="ThreadLocal与Synchronized的区别"></a>ThreadLocal与Synchronized的区别</h3><p>ThreadLocal<T>其实是与线程绑定的一个变量。ThreadLocal和Synchonized都用于解决多线程并发访问。</p><p>ThreadLocal与Synchronized本质区别在于： </p><ol><li>Synchronized用于线程间的数据共享，而ThreadLocal用于线程间的数据隔离。</li><li>Synchronized利用锁机制，使变量或代码块在某一时刻只能被一个线程访问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的共享。而Synchronized却正好相反，用于在多个线程间通信是数据共享。</li></ol><p><em><strong>一句话理解ThreadLocal，threadlocl是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry（threadlocl,value），虽然不同的线程之间threadlocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二的，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程中这个value变量地址是一样的。</strong></em></p><h3 id="ThreadLocal的简单使用"><a href="#ThreadLocal的简单使用" class="headerlink" title="ThreadLocal的简单使用"></a>ThreadLocal的简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocaDemo</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;String&gt;();<br> <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">//打印当前线程中本地内存中本地变量的值</span><br>        System.out.println(str + <span class="hljs-string">&quot; :&quot;</span> + localVar.get());<br>        <span class="hljs-comment">//清除本地内存中的本地变量</span><br>        localVar.remove();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br> <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                ThreadLocaDemo.localVar.set(<span class="hljs-string">&quot;local_A&quot;</span>);<br>                print(<span class="hljs-string">&quot;A&quot;</span>);<br>                <span class="hljs-comment">//打印本地变量</span><br>                System.out.println(<span class="hljs-string">&quot;after remove : &quot;</span> + localVar.get());<br>               <br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();<br> <br>        Thread.sleep(<span class="hljs-number">1000</span>);<br> <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                ThreadLocaDemo.localVar.set(<span class="hljs-string">&quot;local_B&quot;</span>);<br>                print(<span class="hljs-string">&quot;B&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;after remove : &quot;</span> + localVar.get());<br>              <br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br>&#125;<br> <br>A :local_A<br>after remove : <span class="hljs-literal">null</span><br>B :local_B<br>after remove : <span class="hljs-literal">null</span><br> <br></code></pre></td></tr></table></figure><p>从该示例中，两个线程分别获取自己线程存放的变量，变量获取不会错乱。</p>]]></content>
    
    
    <categories>
      
      <category>多线程与并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅谈Threadlocal（1）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Redis为何那么快（一）</title>
    <link href="/2024/03/29/%E6%B5%85%E8%B0%88Redis%E4%B8%BA%E4%BD%95%E9%82%A3%E4%B9%88%E5%BF%AB/"/>
    <url>/2024/03/29/%E6%B5%85%E8%B0%88Redis%E4%B8%BA%E4%BD%95%E9%82%A3%E4%B9%88%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="我们从Redis基于内存操作的特性、高效的内存数据结构、单线程模型、I-O多路复用技术、底层模型和优化技术、持久化机制以及网络通信协议等多个方面进行分析和讨论。通过深入了解Redis内部机制和性能优化技术，我们可以更好地理解Redis之所以快速地根本原因＋在实际应用中发挥其优势。"><a href="#我们从Redis基于内存操作的特性、高效的内存数据结构、单线程模型、I-O多路复用技术、底层模型和优化技术、持久化机制以及网络通信协议等多个方面进行分析和讨论。通过深入了解Redis内部机制和性能优化技术，我们可以更好地理解Redis之所以快速地根本原因＋在实际应用中发挥其优势。" class="headerlink" title="我们从Redis基于内存操作的特性、高效的内存数据结构、单线程模型、I&#x2F;O多路复用技术、底层模型和优化技术、持久化机制以及网络通信协议等多个方面进行分析和讨论。通过深入了解Redis内部机制和性能优化技术，我们可以更好地理解Redis之所以快速地根本原因＋在实际应用中发挥其优势。"></a>我们从Redis基于内存操作的特性、高效的内存数据结构、单线程模型、I&#x2F;O多路复用技术、底层模型和优化技术、持久化机制以及网络通信协议等多个方面进行分析和讨论。通过深入了解Redis内部机制和性能优化技术，我们可以更好地理解Redis之所以快速地根本原因＋在实际应用中发挥其优势。</h4><p><img src="/images/2.png"></p><h1 id="完全基于内存"><a href="#完全基于内存" class="headerlink" title="完全基于内存"></a>完全基于内存</h1><h6 id="相较于依赖磁盘存储的传统数据库系统，Redis巧妙地运用内存的高速读写特性，显著提高系统的响应速度与整体性能表现。内存相对于磁盘具有无可比拟的读写速度优势。在读取操作层面，Redis无需经过耗时的磁盘IO过程，只需在内存空间内迅速定位所需数据，显著降低访问延迟；而在写入操作时，Redis同样直接作用于内存区域，新数据能即刻生效，仅在执行持久化策略时，-例如RDB快照或者AOF日志记录，数据才会异步地或者按需地同步到磁盘，以确保即使在系统重启后数据仍能得以恢复，但此过程并不会妨碍Redis在常规操作中维持其卓越的性能表现。-说到这里，内存资源还是很宝贵的，Redis基于内存操作，它是如何在有限的内存空间中进行精细且高效的内存管理呢？"><a href="#相较于依赖磁盘存储的传统数据库系统，Redis巧妙地运用内存的高速读写特性，显著提高系统的响应速度与整体性能表现。内存相对于磁盘具有无可比拟的读写速度优势。在读取操作层面，Redis无需经过耗时的磁盘IO过程，只需在内存空间内迅速定位所需数据，显著降低访问延迟；而在写入操作时，Redis同样直接作用于内存区域，新数据能即刻生效，仅在执行持久化策略时，-例如RDB快照或者AOF日志记录，数据才会异步地或者按需地同步到磁盘，以确保即使在系统重启后数据仍能得以恢复，但此过程并不会妨碍Redis在常规操作中维持其卓越的性能表现。-说到这里，内存资源还是很宝贵的，Redis基于内存操作，它是如何在有限的内存空间中进行精细且高效的内存管理呢？" class="headerlink" title="相较于依赖磁盘存储的传统数据库系统，Redis巧妙地运用内存的高速读写特性，显著提高系统的响应速度与整体性能表现。内存相对于磁盘具有无可比拟的读写速度优势。在读取操作层面，Redis无需经过耗时的磁盘IO过程，只需在内存空间内迅速定位所需数据，显著降低访问延迟；而在写入操作时，Redis同样直接作用于内存区域，新数据能即刻生效，仅在执行持久化策略时， 例如RDB快照或者AOF日志记录，数据才会异步地或者按需地同步到磁盘，以确保即使在系统重启后数据仍能得以恢复，但此过程并不会妨碍Redis在常规操作中维持其卓越的性能表现。  说到这里，内存资源还是很宝贵的，Redis基于内存操作，它是如何在有限的内存空间中进行精细且高效的内存管理呢？"></a>相较于依赖磁盘存储的传统数据库系统，Redis巧妙地运用内存的高速读写特性，显著提高系统的响应速度与整体性能表现。内存相对于磁盘具有无可比拟的读写速度优势。在读取操作层面，Redis无需经过耗时的磁盘IO过程，只需在内存空间内迅速定位所需数据，显著降低访问延迟；而在写入操作时，Redis同样直接作用于内存区域，新数据能即刻生效，仅在执行持久化策略时， 例如RDB快照或者AOF日志记录，数据才会异步地或者按需地同步到磁盘，以确保即使在系统重启后数据仍能得以恢复，但此过程并不会妨碍Redis在常规操作中维持其卓越的性能表现。  说到这里，内存资源还是很宝贵的，Redis基于内存操作，它是如何在有限的内存空间中进行精细且高效的内存管理呢？</h6><h2 id="过期键删除"><a href="#过期键删除" class="headerlink" title="过期键删除"></a>过期键删除</h2><h3 id="Redis支持为键设置过期时间（TTL）-并且在键过期后会通过两种方式删除它们。"><a href="#Redis支持为键设置过期时间（TTL）-并且在键过期后会通过两种方式删除它们。" class="headerlink" title="Redis支持为键设置过期时间（TTL）,并且在键过期后会通过两种方式删除它们。"></a>Redis支持为键设置过期时间（TTL）,并且在键过期后会通过两种方式删除它们。</h3><ol><li>惰性删除（Lazy Expire):只有当有客户端尝试访问过期键时，Redis才会执行删除操作。优势：避免了不必要的操作，只有在需要时才进行删除。缺点：可能会导致过期键在一段时间内仍占用内存。  </li><li>定期删除（Active Expire):Redis周期性地（默认每10秒）随机抽取一部分键，并检查它们的过期时间。但定期删除会带来额外的CPU消耗。  这两种方式结合，可有效管理和清除过期键，保证Redis的内存使用在合理的范围内。同时，在日常开发中，可以根据业务场景和需求调整过期策略的配置，以达到最佳的性能和内存利用率。</li></ol><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><h6 id="内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的MaxMemory-，Redis会根据预先设置的淘汰策略选择要删除的键，从而释放内存空间。通过合理选择和内存淘汰策略，可以有效管理内存使用，防止内存溢出，并保证系统的稳定性和性能。"><a href="#内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的MaxMemory-，Redis会根据预先设置的淘汰策略选择要删除的键，从而释放内存空间。通过合理选择和内存淘汰策略，可以有效管理内存使用，防止内存溢出，并保证系统的稳定性和性能。" class="headerlink" title="内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的MaxMemory)，Redis会根据预先设置的淘汰策略选择要删除的键，从而释放内存空间。通过合理选择和内存淘汰策略，可以有效管理内存使用，防止内存溢出，并保证系统的稳定性和性能。"></a>内存淘汰策略是Redis用于释放内存空间的一种机制，当内存空间不足时（达到或超过了配置的MaxMemory)，Redis会根据预先设置的淘汰策略选择要删除的键，从而释放内存空间。通过合理选择和内存淘汰策略，可以有效管理内存使用，防止内存溢出，并保证系统的稳定性和性能。</h6><h6 id="常见的内存淘汰策略："><a href="#常见的内存淘汰策略：" class="headerlink" title="常见的内存淘汰策略："></a>常见的内存淘汰策略：</h6><p>1.LRU(最近最少使用)：LRU策略会删除最近最少被访问的键.Redis会记录每一个键最后一次被访问的时间戳，并定期检查这些时间戳，选择最久未被访问的键进行删除。该策略适合于缓存场景，通常最久未被访问的键可能是最不常用的。<br>2.LFU(最不经常使用)：该策略会删除最不经常被访问的键。该策略适合淘汰访问频率最低的键。<br>3.TTL(键的过期时间):该策略会删除已经过期的键。<br>4.随机删除：该策略会随机选择一些键进行删除。虽然这种策略不考虑键的使用频率和过期时间，但某种情况下可能是简单且有效的淘汰方式，特别是当内存空间不足时。<br>5.淘汰固定数量的键：该策略会选择要删除的键的数量，然后按照一定的规则（LRU,LFU）来选择要淘汰的键。这种淘汰可以保证每次淘汰都释放固定数量的内存空间。<br>当Redis的内存使用达到配置的maxmemory限制时，就会触发内存淘汰策略，以释放内存空间。通过合理配置内存限制和内存淘汰策略，可以有效管理Redis的内存使用，保证系统在内存空间不足时能够及时释放内存，避免因内存溢出导致系统性能下降或者崩溃。</p><blockquote><blockquote><p>修改内存maxmemory只需在redis.conf配置文件中配置maxmemory-policy参数即可。</p></blockquote></blockquote><h2 id="内存碎片管理"><a href="#内存碎片管理" class="headerlink" title="内存碎片管理"></a>内存碎片管理</h2><h6 id="内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。"><a href="#内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。" class="headerlink" title="内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。"></a>内存碎片管理是指对Redis中的内存空间进行重新排列和整理，以减少内存碎片的数量和大小。内存碎片是指已分配但不再使用的内存块，这些内存块虽然被标记为已分配，但实际上并未被有效利用，造成了内存的浪费。</h6><h6 id="为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤："><a href="#为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤：" class="headerlink" title="为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤："></a>为了解决内存碎片化的问题，Redis会定期进行内存碎片整理操作。内存碎片整理过程包括以下几个步骤：</h6><p>1.<strong>遍历内存空间</strong>：Redis会遍历整个内存空间，检查每个内存块的状态，包括已分配和未分配的内存块。<br>2. <strong>合并相邻的空闲内存块</strong>：Redis会尝试合并相邻的空闲内存块，将它们合并成一个更大的内存块。这样可以减少内存碎片的数量，提高内存利用率。<br>3.<strong>移动数据</strong>：如果有必要，Redis可能会将数据从一个内存块移动到另一个内存块，以便更好地组织内存空间。这个过程可能会比较耗时，因为需要将数据从一个位置复制到另一个位置。<br>4.<strong>释放不再使用的内存块</strong>：最后，Redis会释放那些不再使用的内存块，以便它们可以被重新分配给新的数据。</p><h6 id="通过定期进行碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化程度，提高内存利用率，从而提高系统的性能和稳定性。但是内存碎片整理过程可能会消耗一定的系统资源，尤其是在内存碎片较多的情况下。所以通常情况下，会选择在系统负载较低的情况下进行碎片整理操作，以避免对系统性能产生不利影响。"><a href="#通过定期进行碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化程度，提高内存利用率，从而提高系统的性能和稳定性。但是内存碎片整理过程可能会消耗一定的系统资源，尤其是在内存碎片较多的情况下。所以通常情况下，会选择在系统负载较低的情况下进行碎片整理操作，以避免对系统性能产生不利影响。" class="headerlink" title="通过定期进行碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化程度，提高内存利用率，从而提高系统的性能和稳定性。但是内存碎片整理过程可能会消耗一定的系统资源，尤其是在内存碎片较多的情况下。所以通常情况下，会选择在系统负载较低的情况下进行碎片整理操作，以避免对系统性能产生不利影响。"></a>通过定期进行碎片整理操作，Redis可以保持内存空间的连续性，减少内存碎片化程度，提高内存利用率，从而提高系统的性能和稳定性。但是内存碎片整理过程可能会消耗一定的系统资源，尤其是在内存碎片较多的情况下。所以通常情况下，会选择在系统负载较低的情况下进行碎片整理操作，以避免对系统性能产生不利影响。</h6>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>本文探讨Redis之所以快速处理大规模数据的原因</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/1970/01/01/hello-world/"/>
    <url>/1970/01/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
