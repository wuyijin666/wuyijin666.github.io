---
title: TIME_WAIT问题，以及如何优化/解决？
date: 2025-11-19 23:35:59
categories:
  - 读书笔记
  - Linux高性能服务器编程
tags:
  - Linux
  - 服务器编程
  - 网络编程
---
### TIME_WAIT问题，以及如何优化/解决？

#### 何时出现TIME_WAIT
![](/images/24.jpg)
从上图可以看到，在客户端收到服务端发过来的报文段6后，客户端进入TIME_WAIT状态，这个状态的持续时间为2MSL。
TIME_WAIT存在的原因有以下两点：
- 可靠地终止TCP连接
- 保证让迟来地TCP报文段有足够地时间被识别并丢弃（或者说 避免历史报文被新的连接接收 ）
  
#### TIME_WAIT持续时间
2MSL ，MSL表示最大 segments lifetime ，即TCP报文段最大的生命期。
坚持2MSL时间，是为了保证网络两个传输方向上尚未被接收到、迟到地tcp报文段都已经消失（被中转路由器丢弃）。


#### 如何解决（避免）TIME_WAIT
![](/images/25.jpg)
使用netstat查看连接状态，可以看到，客户端程序被中断后，连接进入TIME_WAIT状态，12345端口被占用，所以客户端重启失败。
- 事实是，这个例子是我们指定了端口，所以重启失败。客户端程序不用担心这个问题。**因为客户端一般使用系统自动分配的临时端口号来建立连接，而由于随机性**，临时端口号一般和上次使用的端口号不同，所以一般客户端可以重启成功。
- 针对于服务器程序，因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即重启。解决方案：通过socket选项SO_REUSEADDR，允许端口复用。(强制进程立即使用处于TIME_WAIT状态的连接占用的端口)
- 总结： 
  1. 客户端程序主动断连接
  2. 如果是客户端这边有大量time_wait状态的连接，考虑开启tcp_tw_reuse参数，复用time_wait超过1秒的连接。
**ps**: 上文说到：“因为客户端一般使用系统自动分配的临时端口号来建立连接，而由于随机性**，临时端口号一般和上次使用的端口号不同，所以一般客户端可以重启成功。” 那是不是就代表不开启tcp_tw_reuse参数,也可以? 
**回答**： 一般情况是这样的。但是当客户端这边压测服务器，大量并发就会导致连接不够用；且一般情况下，服务器会使用nginx反向代理，那么nginx相对于服务器，就是客户端，那么nginx肯定是要开这个参数的，否则连接无法复用。
  3. 服务端这边，尽量把断开连接的主动权交给客户端。
  4. 服务端断，通过socket选项SO_REUSEADDR，允许端口复用

ps: 需要注意的是，SO_REUSEADDR是用于解决TIME_WAIT状态导致的连接无法使用的问题，（解决的是服务端启动时，总是报Address already in use的错误）但不是解决TIME_WAIT状态的。详情参见：https://xiaolincoding.com/network/3_tcp/port.html#%E5%A4%9A%E4%B8%AA-tcp-%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97