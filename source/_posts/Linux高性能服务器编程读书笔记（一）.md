---
title: Linux高性能服务器编程读书笔记（一）
date: 2025-11-15 15:35:59
categories:
  - 读书笔记
  - Linux高性能服务器编程
tags:
  - Linux
  - 服务器编程
  - 网络编程
---
## 笔记目录 （TCP/IP协议详解）
引言： 我尽量把书中看到的知识点和最近在网络上看到的一些技术文章做一些记录，一是对这部分知识更全面、体系化的思考，二是记录一些不错的知识点，分享给大家，建议大家还是自己亲自读一读。
1. TCP/IP协议族
2. IP协议详解
3. TCP协议详解


## TCP/IP协议族

## IP协议详解

## TCP协议详解
TCP协议理解概述
1. TCP头部信息（用于指定源端口、目标端口、管理TCP链接、控制两个方向的数据流）
2. TCP状态转移过程（TCP连接的任意一端都是一个状态机）
3. Tcp数据流以及对数据流的控制

TCP服务特点
1. 通信双方都必须为该连接分配必要的内核资源，以便管理连接的状态和连接上的数据流传输
2. 一对一连接，因此比起UDP，TCP还有一个特点是不适用基于广播/多播（目标是多个主机地址）的应用程序（这个点，我在被常规八股中，还从来没见到有谁总结过）
3. 思考 数据包 or 字节流 到底在说什么？
回答：当接收端收到一个或多个TCP报文段后，TCP模块将他们携带的应用程序数据按照TCP报文段的顺序依次放入TCP接收缓冲区中并通知应用程序读取数据；应用程序这边，可以一次读完，也可分次去读，取决于用户指定的应用程序读缓冲区的大小。应用程序的读次数和TCP模块接收到的TCP报文段个数无关。

现在我来回答**字节流**的概念：发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，这就是字节流的概念。应用程序对数据的发送和接收无边界限制。UDP则不然。发送端应用程序每执行一次写操作，UDP模块就会封装一个UDP报文段并发送。接收端必须及时接收（执行读操作，通过recvfrom系统调用），不然，就丢包。并且，如果用户指定的应用程序读缓冲区大小不够，UDP报文也会被截断。
来个栩栩如生的好图：
![](/images/22.jpg)
TCP 的可靠：确认应答机制 + 开了个定时器

以及今天看了Julia Evans这篇文章《Why do we use the Linux kernel's TCP stack?》
如果你想用自实现的用户态TCP堆栈，是在追求什么？
A： 
1. 极致性能：
避免内核上下文切换、系统调用和内存拷贝。
可完全控制网络处理逻辑，减少锁竞争和共享状态（符合“端到端原则”）。
2. 灵活性与快速迭代：
内核更新慢，难以支持新协议特性（如 TCP Fast Open）。Google 就因无法强制 Android 厂商升级内核，而更倾向用户态实现。

目前流行不起来的原因何在？
A:
1. 内核 TCP 栈是“默认且合理”的选择，因其成熟、通用、省心。
2. 用户态网络栈适用于极端性能或特殊需求场景（如追求极致性能的交易、超大规模负载均衡）。
3. 势是“将网络处理推向用户态”，以减少内核干预，提升可扩展性与灵活性。
4. 社区正在探索通用化用户态网络方案（如 LKL、libuinet），但尚未成熟。

📌 补充背景
Cloudflare 工程师 Marek Majkowski 在其文章《Why we use the Linux kernel’s TCP stack》直接回应了 Julia Evans 博客的问题，强调了工程实践中“稳健性”和“长期可维护性”往往比理论峰值性能更重要。Cloudflare 的立场代表了许多大型生产系统的务实选择。

正如 Marek 所说：

“We are not in the business of writing TCP stacks. We are in the business of securing and accelerating the web.”

