---
title: 多线程/进程协作方式
date: 2025-11-19 23:35:59
categories:
  - 读书笔记
  - Linux高性能服务器编程
tags:
  - Linux
  - 服务器编程
  - 网络编程
---

## 多进程编程
- 复制进程映像的fork系统调用，替换进程映像的exec系统调用
- 僵尸进程以及如何避免僵尸进程
- 进程间通信方式（Inter-Process Communication，IPC）最最简单的方式：管道
- 3种System V 进程间通信方式：共享内存、消息队列、信号量

#### fork系统调用
```c
pid_t fork(void);
```
该函数每次调用都返回两次，在父进程中返回子进程的进程PID，在子进程中则返回0。该返回值是后续代码判断当前进程是主还是子进程的依据。
子进程代码与父进程的完全相同，同时它还会复制父进程的数据（栈、堆、静态数据）。同时复制采用**写时复制**（COW）即只有在任一进程（父/子）对数据执行了写操作时，复制才会发生（**先是缺页中断，然后操作系统给子进程分配内存并复制父进程的数据）**
#### 处理僵尸进程
僵尸态：
   前提：对于多进程程序而言，父进程一般需要跟踪子进程的退出状态。因此，子进程结束运行时，内核不会立即释放该进程的进程表表项，以满足父进程后续对子进程退出信息的查询（如果父进程还在查询）。
1. 在子进程结束运行之后，父进程读取其退出状态之前，该子进程处于僵尸态
2. 父进程结束或异常终止，而子进程继续运行，该子进程处于僵尸态
   
  无论何种情况，如果父进程没有正确地处理子进程地返回信息，子进程都将停留在僵尸态，并占据着内核资源。
  下面这对函数在父进程中调用，以等待子进程的结束，并获取子进程的返回信息，从而避免了僵尸进程的产生，或使处于僵尸态的子进程立即结束。
  ```c
  pid_t wait(int *status);
  pid_t waitpid(pid_t pid, int *status, int options);
  ```
#### 管道
- 管道实现进程内部的通信，也是父进程与子进程间的通信手段
管道能在父、子进程之间传递数据，利用的是fork调用之后两个管道文件描述符（fd[0] fd[1]）都保持打开。一对这样的文件描述符，只能保证父、子进程间一个方向的数据传输，父/子进程必须有一个关闭fd[0],另一个关闭fd[1]。如图：

显然，父/子进程之间想要双向传递数据，必须使用两个管道。socket编程接口提供了一个创建全双工管道的系统调用：socketpair 。
  
  - 管道只能用于**有关联**的两个进程（父 子）的通信。接下来我们聊聊3种System V IPC能用于**无关联**的多进程之间的通信。因为他们都使用一个全局唯一的键值来标识一条信道。
#### 信号量
##### - 信号量原语
 当多个进程同时访问系统上的某个资源的时候，比如同时写一个数据库的某条记录，或者同时修改某个文件，就需要考虑进程的同步问题，以确保任一时刻只有一个进程可以拥有对资源的独占式访问。
 通常，程序对共享资源的访问的代码只是很短的一段，但这段代码引发了进程之间的竞态条件。我们称这段代码为**关键代码段/临界区**。对进程同步，也就是确保任一时刻只有一个进程能进入关键代码段。
 要编写具有通用目的的代码，以确保关键代码段的独占式访问是非常困难的。
 Dijkstra提出的信号量概念是并发编程领域迈出的重要一步。
 - 信号量
  信号量是一种特殊的变量，它只能取自然数值并且只支持两种操纵：等待（wait）和信号（signal）,不过在Linux/UNIX中，"等待"和"信号"都已经具有特殊的含义，所以对信号量的这两种操作更常用的称呼是P和V操作。
  **p (传递 好像进入临界区)  v (释放 好像退出临界区)**
  假设有信号量SV,则对它的P、V操作，其语义为：
   - P(SV)：如果SV的值＞0，就将它减一；若SV=0，则挂起进程的执行
   - V(SV)：如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，则SV+1
  信号量的取值可以是任何自然数，但最常用的、最简单的信号量是二进制信号量，它只能取0或1这两个值。我们仅讨论二进制信号量。
  使用二进制信号量同步两个进程，以确保关键代码段的独占式访问。
  🌰 举个例子：
  ![](/images/25.jpg)
  当关键代码段可用时，二进制信号量SV的值为1，进程A、B都有机会进入关键代码段。如果此时A执行了P(SV)操作将SV-1，则进程B若再执行P(SV)操作就会被挂起。直到A离开关键代码段，并执行V(SV)操作将SV+1，关键代码段才重新变得可用。如果此时B因为等待SV而处于挂起状态，则它将被唤醒，并进入关键代码段。同样，这时A如果再执行P(SV)操作，则也只能被操作系统挂起以等待B退出关键代码段。
  - PS:
 使用一个普通变量来模拟二进制信号量是不行的。因为所有高级语言都没有一个原子操作可以同时完成如下的两步操作：1. 检测变量是否为false/true  2. 如果是，则再将它设置为false/true
 - Linux信号量的API都定义在sysys/sem.h头文件中，主要包含3个系统调用：semget, semop, semctl。它们都被设计为操作一组信号量，即信号量集，而不是单个信号量。（暂不探讨）
#### 共享内存 
- 共享内存是**最高效**的IPC机制，因为它不涉及进程之间的任何数据传输。这种高效率带来的问题是，我们必须用其他辅助手段来同步进程对共享内存的访问，否则会产生竞态条件。因此，共享内存通常和其他进程间通信方式一起使用。
#### 消息队列
- 消息队列是在两个进程之间传递二进制块数据的一种简单有效的方式。每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据，而不一定像管道/命名管道那样必须以FIFO顺序来接收数据。
#### IPC命令
上述3种System V IPC进程间通信方式都使用一个全局唯一地键值（key）来描述一个共享资源。
当程序调用semget、shmget、msgget等时，就创建了这些共享资源的一个实例。Linux提供了ipcs命令，以观察当前系统上拥有了拥有哪些共享资源实例。如下图：
![](/images/27.jpg)
输出结果分段显示了系统拥有的共享内存、信号量和消息队列资源。目前系统尚未使用任何共享内存和消息队列，却分配了一组键值为0（IPC_PRIVATE）的信号量。这些信号量的所有者是apache,因为它们是由httpd服务器程序创建的。
此外，我们可以使用ipcrm命令来删除这些资源实例。
#### 在进程间传递文件描述符 
- 这一块我没懂想说明什么，暂不讨论。

## 多线程编程
- 创建与结束线程
- 读取和设置线程属性
- POSIX线程同步方式：POSIX信号量、互斥锁、条件变量


本文最后，我们也会讨论下Linux环境下，库函数、进程、信号与多线程程序之间的相互影响。
